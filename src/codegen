struct TextBuffer {
    buffer: char[],
}

fn new_text_buffer(): TextBuffer* {
    let text_buffer = new TextBuffer*;
    text_buffer->buffer = new char[];
    return text_buffer;
}

fn add_to_text_buffer(buffer: TextBuffer*, text: str) {
    let text_length = len(text);
    for (let i = 0; i < text_length; i = i + 1) {
        buffer->buffer.append(text[i]);
    }
}

fn terminate_buffer(buffer: TextBuffer*) {
    buffer->buffer.append('\0');
}


const {
    REG,
    IMM,
    LABEL,
    RELATIVE_LABEL,
    MEM,
};

const {
    MOV,
    LEA,
    ADD,
    SUB,
    IMUL,
    IDIV,
    SAL,
    SAR,
    AND,
    OR,
    XOR,
    CMP,
    TESTZ, // find better name
    NEG,
    NOT,
    CALL,
    PUSH,
    POP,
    SETE,
    SETNE,
    MOVS,
    MOD,
    CMPSETL,
    CMPSETLE,
    CMPSETG,
    CMPSETGE,
    CMPSETE,
    CMPSETNE,
    JMP,
    JMPZ,
    LEAVE,
    RET,
};

const {
    RAX,
    RBX,
    RCX,
    RDX,
    RSI,
    RDI,
    RBP,
    RSP,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
};

const {
    REGISTER_RELATIVE,
    REGISTER_INDEXED,
};

struct Operand {
    value: long,
    type: int,
}

struct Instruction {
    src: Operand*,
    dest: Operand*,
    opcode: int,
    type: int,
}

let instructions: Instruction*[];

fn make_reg(reg: long): Operand* {
    let operand = new Operand*;
    operand->value = reg;
    operand->type = REG;
    return operand;
}


fn make_imm(imm: long): Operand* {
    let operand = new Operand*;
    operand->value = imm;
    operand->type = IMM;
    return operand;
}

fn make_label(label: ptr): Operand* {
    let operand = new Operand*;
    operand->value = label as long;
    operand->type = LABEL;
    return operand;
}

fn make_relative_label(label: str): Operand* {
    let operand = new Operand*;
    operand->value = label as long;
    operand->type = RELATIVE_LABEL;
    return operand;
}

fn make_mem(base_register: Operand*, index_register: Operand*, scale: int, offset: int, mode: int): Operand* {
    // be careful with the long casts, the value needs to be cast to long before the bitwise operations
    let operand = new Operand*;
    operand->value = (offset & (((1 as long) << 32) - 1));
    operand->value = operand->value | ((scale as long & 15) << 32);
    if (index_register) {
        operand->value = operand->value | ((index_register->value & 31) << 36);
    } else {
        operand->value = operand->value | (31 as long << 36);
    }
    if (base_register) {
        operand->value = operand->value | ((base_register->value & 31) << 41);
    } else {
        operand->value = operand->value | (31 as long << 41);
    }
    operand->value = operand->value | ((mode & 3) as long << 46);
    operand->type = MEM;
    return operand;
}

fn make_stack(offset: int): Operand* {
    return make_mem(make_reg(RBP as long), 0 as Operand*, 0, offset, REGISTER_RELATIVE);
}

fn emit_instruction(text_buffer: TextBuffer*, instruction: Instruction*)

fn add_instruction(text_buffer: TextBuffer*, src: Operand*, dest: Operand*, opcode: int, type: int) {
    let instruction = new Instruction*;
    instruction->src = src;
    instruction->dest = dest;
    instruction->opcode = opcode;
    instruction->type = type;
    instructions.append(instruction);
    emit_instruction(text_buffer, instruction);
}

let register_names_byte: str[];
let register_names_dword: str[];
let register_names_qword: str[];

fn emit_operand_x86(text_buffer: TextBuffer*, operand: Operand*, size: int) {
    if (operand->type == REG) {
        if (operand->value == 31) {
            return;
        }
        if (size == 1) {
            add_to_text_buffer(text_buffer, register_names_byte[operand->value]);
        }
        elseif (size == 4) {
            add_to_text_buffer(text_buffer, register_names_dword[operand->value]);
        }
        elseif (size == 8) {
            add_to_text_buffer(text_buffer, register_names_qword[operand->value]);
        }
        else {
            print("Unknown size for operand " + int_to_str(size) + "\n");
        }
    }
    elseif (operand->type == MEM) {
        let mode = (operand->value >> 46) & 3;
        let offset = (operand->value & (((1 as long) << 32) - 1)) as int;
        let base_register = (operand->value >> 41) & 31;
        let index_register = (operand->value >> 36) & 31;
        let scale = (operand->value >> 32) & 15;

        if (mode == REGISTER_RELATIVE) {
            if (offset != 0) {
                add_to_text_buffer(text_buffer, offset.int_to_str());
            }
            add_to_text_buffer(text_buffer, "(");
            emit_operand_x86(text_buffer, make_reg(base_register), 8);
            add_to_text_buffer(text_buffer, ")");
        }
        elseif (mode == REGISTER_INDEXED) {
            add_to_text_buffer(text_buffer, "(");
            emit_operand_x86(text_buffer, make_reg(base_register), 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_x86(text_buffer, make_reg(index_register), 8);
            add_to_text_buffer(text_buffer, ", ");
            add_to_text_buffer(text_buffer, long_to_str(scale));
            add_to_text_buffer(text_buffer, ")");
        }
        else {
            print("Unknown mode " + int_to_str(mode as int) + "\n");
        }
    }
    elseif (operand->type == IMM) {
        add_to_text_buffer(text_buffer, "$" + long_to_str(operand->value));
    }
    elseif (operand->type == LABEL) {
        add_to_text_buffer(text_buffer, operand->value);
    }
    elseif (operand->type == RELATIVE_LABEL) {
        add_to_text_buffer(text_buffer, "." + operand->value as str + "(%rip)");
    }
    else {
        print("Unknown operand type " + int_to_str(operand->type) + "\n");
    }
}

fn add_size_letter(text_buffer: TextBuffer*, size: int) {
    if (size == 1) {
        add_to_text_buffer(text_buffer, "b");
    }
    elseif (size == 4) {
        add_to_text_buffer(text_buffer, "l");
    }
    elseif (size == 8) {
        add_to_text_buffer(text_buffer, "q");
    }
}

fn emit_instruction_x86(text_buffer: TextBuffer*, instruction: Instruction*) {
    let opcode = instruction->opcode;
    let size = get_size(instruction->type);
    let two_operand_instruction = opcode == MOV || opcode == LEA || opcode == SUB || opcode == ADD || opcode == CMP || opcode == IMUL || opcode == AND || opcode == OR || opcode == XOR;
    let cmpset_instruction = opcode == CMPSETL || opcode == CMPSETLE || opcode == CMPSETG || opcode == CMPSETGE || opcode == CMPSETE || opcode == CMPSETNE;
    let jmp_instruction = opcode == JMP || opcode == JMPZ;
    if (two_operand_instruction) {
        if (opcode == MOV) {
            add_to_text_buffer(text_buffer, "\tmov");
        }
        elseif (opcode == LEA) {
            add_to_text_buffer(text_buffer, "\tlea");
        }
        elseif (opcode == SUB) {
            add_to_text_buffer(text_buffer, "\tsub");
        }
        elseif (opcode == ADD) {
            add_to_text_buffer(text_buffer, "\tadd");
        }
        elseif (opcode == CMP) {
            add_to_text_buffer(text_buffer, "\tcmp");
        }
        elseif (opcode == IMUL) {
            add_to_text_buffer(text_buffer, "\timul");
        }
        elseif (opcode == AND) {
            add_to_text_buffer(text_buffer, "\tand");
        }
        elseif (opcode == OR) {
            add_to_text_buffer(text_buffer, "\tor");
        }
        elseif (opcode == XOR) {
            add_to_text_buffer(text_buffer, "\txor");
        }
        else {
            print("Unknown opcode " + int_to_str(opcode as int) + "\n");
        }

        add_size_letter(text_buffer, size);

        add_to_text_buffer(text_buffer, " ");
        emit_operand_x86(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_x86(text_buffer, instruction->dest, size);
        add_to_text_buffer(text_buffer, "\n");
    }
    elseif (cmpset_instruction) {
        add_to_text_buffer(text_buffer, "\tcmp");
        add_size_letter(text_buffer, size);
        add_to_text_buffer(text_buffer, " ");
        emit_operand_x86(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_x86(text_buffer, instruction->dest, size);
        add_to_text_buffer(text_buffer, "\n\tset");
        if (opcode == CMPSETL) {
            add_to_text_buffer(text_buffer, "l");
        }
        elseif (opcode == CMPSETLE) {
            add_to_text_buffer(text_buffer, "le");
        }
        elseif (opcode == CMPSETG) {
            add_to_text_buffer(text_buffer, "g");
        }
        elseif (opcode == CMPSETGE) {
            add_to_text_buffer(text_buffer, "ge");
        }
        elseif (opcode == CMPSETE) {
            add_to_text_buffer(text_buffer, "e");
        }
        elseif (opcode == CMPSETNE) {
            add_to_text_buffer(text_buffer, "ne");
        }
        add_to_text_buffer(text_buffer, " ");
        add_to_text_buffer(text_buffer, "%al"); // TODO: fix this so that there are no hardcoded registers
        add_to_text_buffer(text_buffer, "\n");
    }
    elseif (jmp_instruction) {
        if (opcode == JMP) {
            add_to_text_buffer(text_buffer, "\tjmp");
        }
        elseif (opcode == JMPZ) {
            add_to_text_buffer(text_buffer, "\tjz");
        }
        else {
            print("Unknown opcode " + int_to_str(opcode as int) + "\n");
        }
        add_to_text_buffer(text_buffer, " .");
        emit_operand_x86(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, "\n");
    }
    else {
        if (opcode == NEG) {
            add_to_text_buffer(text_buffer, "\tneg");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == NOT) {
            add_to_text_buffer(text_buffer, "\tnot");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == TESTZ) {
            add_to_text_buffer(text_buffer, "\ttest");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n\tsetz ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == CALL) {
            add_to_text_buffer(text_buffer, "\tcall ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SETE) {
            add_to_text_buffer(text_buffer, "\tsete ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SETNE) {
            add_to_text_buffer(text_buffer, "\tsetne ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == PUSH) {
            add_to_text_buffer(text_buffer, "\tpush");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == POP) {
            add_to_text_buffer(text_buffer, "\tpop");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SAL) {
            // move byte from source to cl
            add_to_text_buffer(text_buffer, "\tmovb ");
            emit_operand_x86(text_buffer, instruction->src, 1);
            add_to_text_buffer(text_buffer, ", %cl\n");
            add_to_text_buffer(text_buffer, "\tsal");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            add_to_text_buffer(text_buffer, "%cl, ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SAR) {
            add_to_text_buffer(text_buffer, "\tmovb ");
            emit_operand_x86(text_buffer, instruction->src, 1);
            add_to_text_buffer(text_buffer, ", %cl\n");
            add_to_text_buffer(text_buffer, "\tsar");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            add_to_text_buffer(text_buffer, "%cl, ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == LEAVE) { 
            add_to_text_buffer(text_buffer, "\tleave\n");
        }
        elseif (opcode == RET) {
            add_to_text_buffer(text_buffer, "\tret\n");
        }
        elseif (opcode == IDIV) {
            if (size == 4) {
                // TODO: fix this so that there are no hardcoded registers
                add_to_text_buffer(text_buffer, "\tmovl ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %ebx\n");
                add_to_text_buffer(text_buffer, "\tcdq\n");
                add_to_text_buffer(text_buffer, "\tidivl %ebx\n");
            }
            elseif (size == 8) {
                add_to_text_buffer(text_buffer, "\tmovq ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %rbx\n");
                add_to_text_buffer(text_buffer, "\tcqo\n");
                add_to_text_buffer(text_buffer, "\tidivq %rbx\n");
            }
            else {
                print("Unknown size for division" + int_to_str(size) + "\n");
            }
        }
        elseif (opcode == MOD) {
            if (size == 4) {
                add_to_text_buffer(text_buffer, "\tmovl ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %ebx\n");
                add_to_text_buffer(text_buffer, "\tcdq\n");
                add_to_text_buffer(text_buffer, "\tidivl %ebx\n");
                add_to_text_buffer(text_buffer, "\tmovl %edx, ");
                emit_operand_x86(text_buffer, instruction->dest, size);
                add_to_text_buffer(text_buffer, "\n");
            }
            elseif (size == 8) {
                add_to_text_buffer(text_buffer, "\tmovq ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %rbx\n");
                add_to_text_buffer(text_buffer, "\tcqo\n");
                add_to_text_buffer(text_buffer, "\tidivq %rbx\n");
                add_to_text_buffer(text_buffer, "\tmovq %rdx, ");
                emit_operand_x86(text_buffer, instruction->dest, size);
                add_to_text_buffer(text_buffer, "\n");
            }
            else {
                print("Unknown size for modulo" + int_to_str(size) + "\n");
            }
        }
        elseif (opcode & MOVS == MOVS) { // THIS MUST BE LAST BECAUSE IT USES A BITMASK
            add_to_text_buffer(text_buffer, "\tmovs");
            let src_size = (opcode >> 16) & 15;
            let dst_size = (opcode >> 20) & 15;
            add_size_letter(text_buffer, src_size);
            add_size_letter(text_buffer, dst_size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, src_size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_x86(text_buffer, instruction->dest, dst_size);
            add_to_text_buffer(text_buffer, "\n");
        }
        else {
            print("Unknown instruction opcode " + int_to_str(opcode) + "\n");
        }
    }
}

fn emit_instruction(text_buffer: TextBuffer*, instruction: Instruction*) {
    emit_instruction_x86(text_buffer, instruction);
}

fn encode_sizes_in_opcode(opcode: int, src_type: int, dst_type: int): int {
    let src_size = get_size(src_type);
    let dst_size = get_size(dst_type);
    opcode = opcode | (src_size << 16);
    opcode = opcode | (dst_size << 20);
    return opcode;
}

let rsp_offset = 0;

fn align_stack(text_buffer: TextBuffer*, offset: int): int {
    let alignment_offset = (offset % 16 + 16) % 16;

    if (alignment_offset != 0) {
        //add_to_text_buffer(text_buffer, "\tsubq $" + int_to_str(alignment_offset) + ", %rsp\n");
        add_instruction(text_buffer, make_imm(alignment_offset as long), make_reg(RSP as long), SUB, LONG_VARIABLE);
        rsp_offset = rsp_offset - alignment_offset;
    }
    return alignment_offset;
}

fn dealign_stack(text_buffer: TextBuffer*, offset: int) {
    if (offset != 0) {
        //add_to_text_buffer(text_buffer, "\taddq $" + int_to_str(offset) + ", %rsp\n");
        add_instruction(text_buffer, make_imm(offset as long), make_reg(RSP as long), ADD, LONG_VARIABLE);
        rsp_offset = rsp_offset + offset;
    }
}

fn print_stack_frame_size(text_buffer: TextBuffer*, stack_frame: StackFrame*) {
    let stack_frame_size = -(stack_frame->stack_size);
    if (stack_frame_size > 0) {
        stack_frame_size = (stack_frame_size + 15) & (!15);
        if (text_buffer) {
            //add_to_text_buffer(text_buffer, "\tsubq $" + int_to_str(stack_frame_size) + ", %rsp\n");
            add_instruction(text_buffer, make_imm(stack_frame_size as long), make_reg(RSP as long), SUB, LONG_VARIABLE);
        }
        else {
            print("\tsubq $" + int_to_str(stack_frame_size) + ", %rsp\n");
        }
    }
}

let label_index = 0;

fn get_label_index(): int {
    label_index = label_index + 1;
    return label_index;
}

fn get_register_for_size(reg: char, size: int): str {
    if (size == 1) {
        return "%" + reg + "l";
    }
    elseif (size == 4) {
        return "%e" + reg + "x";
    }
    elseif (size == 8) {
        return "%r" + reg + "x";
    }
    else {
        print("Unknown size for register " + int_to_str(size) + "\n");
    }
}

fn get_register_for_type(reg: char, type: int): str {
    let size = get_size(type);
    return get_register_for_size(reg, size);
}

fn compile_expression_into_register(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, reg: char, type: int): int

fn compile_unary_expression(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, type: int): int {
    let unary_expression_node = (node->node as UnaryExpressionNode*);
    let lrtype = RVALUE;
    if (unary_expression_node->unary_expression_type == AT) {
        lrtype = LVALUE;
    }
    let value_type = compile_expression_into_register(text_buffer, unary_expression_node->value, stack_frame, 'a', lrtype);
    let pointer_register_name = get_register_for_type('a', value_type);

    if (unary_expression_node->unary_expression_type == ASTERISK && type == RVALUE) {
        if (is_pointer(value_type) || is_array(value_type)) {
            value_type = dereference_type(value_type);
        }
        else {
            print("Unary * must have a pointer or an array as a type\n");
        }
    }

    let register_name = get_register_for_type('a', value_type);
    let word_size = get_word_size(get_size(value_type));

    if (unary_expression_node->unary_expression_type == MINUS) {
        if (type == LVALUE) {
            print("Unary minus is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tneg " + register_name + "\n");
        add_instruction(text_buffer, 0 as Operand*, make_reg(RAX as long), NEG, value_type);
    }
    elseif (unary_expression_node->unary_expression_type == PLUS) {
        if (type == LVALUE) {
            print("Unary plus is not allowed as lvalue\n");
        }
    }
    elseif (unary_expression_node->unary_expression_type == ASTERISK) {
        if (type == RVALUE) {
            //add_to_text_buffer(text_buffer, "\tmov" + word_size + " (" + pointer_register_name + "), " + register_name + "\n");

            add_instruction(text_buffer, make_mem(make_reg(RAX as long), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(RAX as long), MOV, value_type);
        }
        elseif (type == LVALUE) {
            //add_to_text_buffer(text_buffer, "\tleaq" + " (" + pointer_register_name + "), " + register_name + "\n");

            add_instruction(text_buffer, make_reg(RAX as long), make_reg(RAX as long),  MOV, LONG_VARIABLE); // this does nothing, this lea can be a mov
        }
    }
    elseif (unary_expression_node->unary_expression_type == BANG) {
        //TODO: add tilde and fix this
        if (value_type == BOOL_VARIABLE) {
            //add_to_text_buffer(text_buffer, "\ttestb " + register_name + ", " + register_name + "\n\tsetz %al\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(RAX as long), TESTZ, BOOL_VARIABLE);
        }
        else {
            //add_to_text_buffer(text_buffer, "\tnot " + register_name + "\n");
            add_instruction(text_buffer, 0 as Operand*, make_reg(RAX as long), NOT, value_type);
        }
    }
    else {
        print("Unknown unary expression type " + debug_token_value_to_str(unary_expression_node->unary_expression_type) + "\n");
        add_to_text_buffer(text_buffer, "Unknown unary expression type " + int_to_str(unary_expression_node->unary_expression_type) + "\n");
    }
    return value_type;
}

fn compile_char_into_builder(text_buffer: TextBuffer*) {
    let index = get_label_index();

    let alignment_offset = align_stack(text_buffer, rsp_offset);
    add_instruction(text_buffer, make_label("__append_char_to_builder"), 0 as Operand*, CALL, VOID);
    //add_to_text_buffer(text_buffer, "\tcall __append_char_to_builder\n");
    dealign_stack(text_buffer, alignment_offset);
}

fn compile_string_into_builder(text_buffer: TextBuffer*) {
    let ___index = get_label_index();
    
    let alignment_offset = align_stack(text_buffer, rsp_offset);
    //add_to_text_buffer(text_buffer, "\tcall __append_string_to_builder\n");
    add_instruction(text_buffer, make_label("__append_string_to_builder"), 0 as Operand*, CALL, VOID);
    dealign_stack(text_buffer, alignment_offset);
}

fn compile_binary_expression(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*): int {
    let binary_expression_node = (node->node as BinaryExpressionNode*);
    let operator = binary_expression_node->binary_expression_type;
    let right_expression_type = binary_expression_node->right->type;

    let preserve_rax = right_expression_type == EXPRESSION_BINARY || right_expression_type == EXPRESSION_FUNCTION_CALL || right_expression_type == EXPRESSION_ARROW || right_expression_type == EXPRESSION_UNARY || right_expression_type == EXPRESSION_INDEX || right_expression_type == EXPRESSION_AS || right_expression_type == EXPRESSION_DOUBLE_COLON;

    let left_type = compile_expression_into_register(text_buffer, binary_expression_node->left, stack_frame, 'a', RVALUE);

    if (preserve_rax) {
        //add_to_text_buffer(text_buffer, "\tpushq %rax\n");
        add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, PUSH, LONG_VARIABLE);
        rsp_offset = rsp_offset - 8;
    }

    let right_type = compile_expression_into_register(text_buffer, binary_expression_node->right, stack_frame, 'd', RVALUE);

    if (preserve_rax) {
        //add_to_text_buffer(text_buffer, "\tpopq %rax\n");
        add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, POP, LONG_VARIABLE);
        rsp_offset = rsp_offset + 8;
    }

    let right_underlying_type = get_underlying_type(right_type);
    let is_right_char = (right_underlying_type == to_pointer(CHAR_VARIABLE)) || (right_underlying_type == CHAR_VARIABLE);

    let left_underlying_type = get_underlying_type(left_type);
    let is_left_char = (left_underlying_type == to_pointer(CHAR_VARIABLE)) || (left_underlying_type == CHAR_VARIABLE);

    if (operator == PLUS && left_type == STRING_BUILDER_VARIABLE && is_right_char && right_expression_type != EXPRESSION_FUNCTION_CALL) {
        //add_to_text_buffer(text_buffer, "\tmovq %rdx, %r12\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(R12 as long), MOV, LONG_VARIABLE);
        if (right_type == CHAR_VARIABLE) {
            compile_char_into_builder(text_buffer);
        }
        else {
            compile_string_into_builder(text_buffer);
        }

        //add_to_text_buffer(text_buffer, "\tmovq %r15, %rax\n");
        add_instruction(text_buffer, make_reg(R15 as long), make_reg(RAX as long), MOV, LONG_VARIABLE);
        return STRING_BUILDER_VARIABLE;
    }
    elseif (operator == PLUS && is_left_char && is_right_char) {
        //add_to_text_buffer(text_buffer, "\tpushq %rdx\n");
        add_instruction(text_buffer, make_reg(RDX as long), 0 as Operand*, PUSH, LONG_VARIABLE);
        rsp_offset = rsp_offset - 8;

        //add_to_text_buffer(text_buffer, "\tpushq %rax\n");
        add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, PUSH, LONG_VARIABLE);
        rsp_offset = rsp_offset - 8;

        //add_to_text_buffer(text_buffer, "\tmovq $64, %rdi\n");
        add_instruction(text_buffer, make_imm(64 as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tcall malloc\n");
        add_instruction(text_buffer, make_label("malloc"), 0 as Operand*, CALL, VOID);
        //add_to_text_buffer(text_buffer, "\tmovq %rax, %r15\n");
        add_instruction(text_buffer, make_reg(RAX as long), make_reg(R15 as long), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tmovq $0, %r14\n");
        add_instruction(text_buffer, make_imm(0 as long), make_reg(R14 as long), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tmovq $64, %r13\n");
        add_instruction(text_buffer, make_imm(64 as long), make_reg(R13 as long), MOV, LONG_VARIABLE);

        //add_to_text_buffer(text_buffer, "\tpopq %r12\n");
        add_instruction(text_buffer, make_reg(R12 as long), 0 as Operand*, POP, LONG_VARIABLE);
        rsp_offset = rsp_offset + 8;
        if (left_type == CHAR_VARIABLE) {
            compile_char_into_builder(text_buffer);
        }
        else {
            compile_string_into_builder(text_buffer);
        }

        //add_to_text_buffer(text_buffer, "\tpopq %r12\n");
        add_instruction(text_buffer, make_reg(R12 as long), 0 as Operand*, POP, LONG_VARIABLE);
        rsp_offset = rsp_offset + 8;
        if (right_type == CHAR_VARIABLE) {
            compile_char_into_builder(text_buffer);
        }
        else {
            compile_string_into_builder(text_buffer);
        }

        //add_to_text_buffer(text_buffer, "\tmovq %r15, %rax\n");
        add_instruction(text_buffer, make_reg(R15 as long), make_reg(RAX as long), MOV, LONG_VARIABLE);
        return STRING_BUILDER_VARIABLE;
    }

    
    if ((operator == EQ || operator == NEQ) && 
        (get_underlying_type(left_type) == to_pointer(CHAR_VARIABLE)) &&
        (get_underlying_type(right_type) == to_pointer(CHAR_VARIABLE))) {
        //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
        add_instruction(text_buffer, make_reg(RAX as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rsi\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RSI as long), MOV, LONG_VARIABLE);

        let alignment_offset = align_stack(text_buffer, rsp_offset);
        //add_to_text_buffer(text_buffer, "\tcall strcmp\n");
        add_instruction(text_buffer, make_label("strcmp"), 0 as Operand*, CALL, VOID);
        //add_to_text_buffer(text_buffer, "\tcmpq $0, %rax\n");
        add_instruction(text_buffer, make_imm(0 as long), make_reg(RAX as long), CMP, LONG_VARIABLE);
        if (operator == EQ) {
            //add_to_text_buffer(text_buffer, "\tsete %al\n");
            add_instruction(text_buffer, 0 as Operand*, make_reg(RAX as long), SETE, BOOL_VARIABLE);
        }
        elseif (operator == NEQ) {
            //add_to_text_buffer(text_buffer, "\tsetne %al\n");
            add_instruction(text_buffer, 0 as Operand*, make_reg(RAX as long), SETNE, BOOL_VARIABLE);
        }
        else {
            print("Unknown operator to compare 2 strings " + int_to_str(operator) + "\n");
        }
        dealign_stack(text_buffer, alignment_offset);
        return BOOL_VARIABLE;
    }

    left_type = get_underlying_type(left_type);
    right_type = get_underlying_type(right_type);

    if (left_type != right_type) {
        if ((left_type == CHAR_VARIABLE || left_type == INT_VARIABLE || left_type == LONG_VARIABLE) && (right_type == CHAR_VARIABLE || right_type == INT_VARIABLE || right_type == LONG_VARIABLE)) {
            let left_size = get_size(left_type);
            let right_size = get_size(right_type);

            if (left_size < right_size) {
                let source_register = get_register_for_type('a', left_type);
                let destination_register = get_register_for_type('a', right_type);

                //add_to_text_buffer(text_buffer, "\tmovs" + get_word_size(left_size) + get_word_size(right_size) + " " + source_register + ", " + destination_register + "\n");
                add_instruction(text_buffer, make_reg(RAX as long), make_reg(RAX as long), encode_sizes_in_opcode(MOVS, left_type, right_type), VOID);
                left_type = right_type;

            }
            elseif (right_size < left_size) {
                let source_register = get_register_for_type('d', right_type);
                let destination_register = get_register_for_type('d', left_type);

                //add_to_text_buffer(text_buffer, "\tmovs" + get_word_size(right_size) + get_word_size(left_size) + " " + source_register + ", " + destination_register + "\n");
                add_instruction(text_buffer, make_reg(RDX as long), make_reg(RDX as long), encode_sizes_in_opcode(MOVS, right_type, left_type), VOID);
                right_type = left_type;
            }
        }
        elseif ((is_pointer(left_type) || left_type == PTR_VARIABLE) && (is_pointer(right_type) || right_type == PTR_VARIABLE)) {
            left_type = PTR_VARIABLE;
            right_type = PTR_VARIABLE;
        }
        else {
            print("Implicit conversion of non numeric types not implemented\n");
        }
    }
  
    let type = left_type;

    let left_register = get_register_for_type('a', left_type);
    let right_register = get_register_for_type('d', right_type);

    let word_size = get_word_size(get_size(left_type));
    if (operator == PLUS) {
        //add_to_text_buffer(text_buffer, "\tadd" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), ADD, type);
    }
    elseif (operator == MINUS) {
        //add_to_text_buffer(text_buffer, "\tsub" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), SUB, type);
    }
    elseif (operator == ASTERISK) {
        //add_to_text_buffer(text_buffer, "\timul" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), IMUL, type);
    }
    elseif (operator == SLASH) {
        if (type != INT_VARIABLE && type != LONG_VARIABLE) {
            print("Division not implemented for non-int types\n");
        }
        if (get_size(type) == 4) {
            //add_to_text_buffer(text_buffer, "\tmovl %edx, %ebx\n"); //add_to_text_buffer(text_buffer, "\tcdq\n"); //add_to_text_buffer(text_buffer, "\tidivl %ebx\n");
        }
        elseif (get_size(type) == 8) {
            //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rbx\n"); //add_to_text_buffer(text_buffer, "\tcqo\n"); //add_to_text_buffer(text_buffer, "\tidivq %rbx\n");
        }
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), IDIV, type);
    }
    elseif (operator == MODULO) {
        if (type != INT_VARIABLE && type != LONG_VARIABLE) {
            print("Modulo not implemented for non-int types\n");
        }
        if (get_size(type) == 4) {
            //add_to_text_buffer(text_buffer, "\tmovl %edx, %ebx\n"); //add_to_text_buffer(text_buffer, "\tcdq\n"); //add_to_text_buffer(text_buffer, "\tidivl %ebx\n"); //add_to_text_buffer(text_buffer, "\tmovl %edx, %eax\n");
        }
        elseif (get_size(type) == 8) {
            //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rbx\n"); //add_to_text_buffer(text_buffer, "\tcqo\n"); //add_to_text_buffer(text_buffer, "\tidivq %rbx\n"); //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rax\n");
        }
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), MOD, type);
    }
    elseif (operator == LT) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetl %al\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), CMPSETL, type);
    }
    elseif (operator == LTE) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetle %al\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), CMPSETLE, type);
    }
    elseif (operator == GT) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetg %al\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), CMPSETG, type);
    }
    elseif (operator == GTE) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetge %al\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), CMPSETGE, type);
    }
    elseif (operator == EQ) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsete %al\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), CMPSETE, type);
    }
    elseif (operator == NEQ) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetne %al\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), CMPSETNE, type);
    }
    elseif (operator == LOGICAL_AND || operator == BITWISE_AND) {
        //add_to_text_buffer(text_buffer, "\tand" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), AND, type);
    }
    elseif (operator == LOGICAL_OR || operator == BITWISE_OR) {
        //add_to_text_buffer(text_buffer, "\tor" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), OR, type);
    }
    elseif (operator == LOGICAL_XOR || operator == BITWISE_XOR) {
        //add_to_text_buffer(text_buffer, "\txor" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), XOR, type);
    }
    elseif (operator == BITWISE_LEFT_SHIFT) {
        //add_to_text_buffer(text_buffer, "\tmovb %dl, %cl\n"); //add_to_text_buffer(text_buffer, "\tsal" + word_size + " %cl, " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), SAL, type);
    }
    elseif (operator == BITWISE_RIGHT_SHIFT) {
        //add_to_text_buffer(text_buffer, "\tmovb %dl, %cl\n"); //add_to_text_buffer(text_buffer, "\tsar" + word_size + " %cl, " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX as long), make_reg(RAX as long), SAR, type);
    }
    else {
        print("Unknown binary expression type " + int_to_str(operator) + "\n");
    }

    if (operator == PLUS || operator == MINUS || operator == ASTERISK || operator == SLASH || operator == MODULO || operator == BITWISE_AND || operator == BITWISE_OR || operator == BITWISE_XOR || operator == BITWISE_LEFT_SHIFT || operator == BITWISE_RIGHT_SHIFT) {
        return type;
    }
    elseif (operator == LT || operator == LTE || operator == GT || operator == GTE || operator == EQ || operator == NEQ || operator == LOGICAL_AND || operator == LOGICAL_OR || operator == LOGICAL_XOR) {
        return BOOL_VARIABLE;
    }
    else {
        print("Unknown binary expression type " + int_to_str(operator) + "\n");
    }
}

fn compile_function_call(node: AstNode*, text_buffer: TextBuffer*, stack_frame: StackFrame*, reg: char, type: int): int {
    let function_call_node = (node->node as FunctionCallNode*);
    let name = function_call_node->name;

    let REGREG = RAX; // VERY TEMPORARY TODO TODO Remove this
    if (reg == 'a') {
        REGREG = RAX;
    }
    elseif (reg == 'd') {
        REGREG = RDX;
    }
    else {
        print("Unknown register for function call " + reg + "\n");
    }


    if (name == "len") {
        if (type == LVALUE) {
            print("len function is not allowed as lvalue\n");
        }
        if (function_call_node->arguments.len() != 1) {
            print("len function takes exactly one argument\n");
        }
        let argument = function_call_node->arguments[0];
        let argument_type = compile_expression_into_register(text_buffer, argument, stack_frame, 'a', RVALUE);
        if (argument_type == STRING_VARIABLE || argument_type == STRING_LITERAL_VARIABLE || argument_type == STRING_BUILDER_VARIABLE) {
            let alignment_offset = align_stack(text_buffer, rsp_offset);
            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(RDI as long), MOV, LONG_VARIABLE);

            //add_to_text_buffer(text_buffer, "\tcall strlen\n");
            add_instruction(text_buffer, make_label("strlen"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovl %eax, " + get_register_for_type(reg, INT_VARIABLE) + "\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(REGREG as long), MOV, INT_VARIABLE);
            dealign_stack(text_buffer, alignment_offset);
            return INT_VARIABLE;
        }
        elseif (is_array(argument_type)) {
            //add_to_text_buffer(text_buffer, "\tmovl 8(%rax), " + get_register_for_type(reg, INT_VARIABLE) + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX as long), 0 as Operand*, 0, 8, REGISTER_RELATIVE), make_reg(REGREG as long), MOV, INT_VARIABLE);
            return INT_VARIABLE;
        }
        else {
            print("Len function can only be used on strings and arrays\n");
        }
    }
    elseif (name == "capacity") {
        if (type == LVALUE) {
            print("capacity function is not allowed as lvalue\n");
        }
        if (function_call_node->arguments.len() != 1) {
            print("capacity function takes exactly one argument\n");
        }
        let argument = function_call_node->arguments[0];
        let argument_type = compile_expression_into_register(text_buffer, argument, stack_frame, 'a', RVALUE);
        if (is_array(argument_type)) {
            //add_to_text_buffer(text_buffer, "\tmovl " + int_to_str(12) + "(%rax), " + get_register_for_type(reg, INT_VARIABLE) + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX as long), 0 as Operand*, 0, 12, REGISTER_RELATIVE), make_reg(REGREG as long), MOV, INT_VARIABLE);

            return INT_VARIABLE;
        }
        else {
            print("Capacity function can only be used on arrays\n");
        }
    }
    elseif (name == "append") {
        if (function_call_node->arguments.len() != 2) {
            print("append function takes exactly two arguments, got " + int_to_str(function_call_node->arguments.len()) + "\n");
        }
        let alignment_offset = align_stack(text_buffer, rsp_offset);

        let array_type = compile_expression_into_register(text_buffer, function_call_node->arguments[0], stack_frame, 'a', RVALUE);

        //add_to_text_buffer(text_buffer, "\tpushq %rax\n");
        add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, PUSH, LONG_VARIABLE);
        rsp_offset = rsp_offset - 8;

        let element_type = compile_expression_into_register(text_buffer, function_call_node->arguments[1], stack_frame, 'b', RVALUE);

        //add_to_text_buffer(text_buffer, "\tpopq %rax\n");
        add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, POP, LONG_VARIABLE);
        rsp_offset = rsp_offset + 8;

        let ___index = get_label_index(); // TODO: remove this later, this is here so that the label numbers are the same as before

        let size = get_size(element_type);
        if (size == 1) {
            //add_to_text_buffer(text_buffer, "\tcall __append_char\n");
            add_instruction(text_buffer, make_label("__append_char"), 0 as Operand*, CALL, VOID);
        }
        elseif (size == 4) {
            //add_to_text_buffer(text_buffer, "\tcall __append_long\n");
            add_instruction(text_buffer, make_label("__append_long"), 0 as Operand*, CALL, VOID);
        }
        elseif (size == 8) {
            //add_to_text_buffer(text_buffer, "\tcall __append_quad\n");
            add_instruction(text_buffer, make_label("__append_quad"), 0 as Operand*, CALL, VOID);
        }

        
        if (type == LVALUE) {
            element_type = to_pointer(element_type);
        }

        if (type == RVALUE) {
            //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(element_type)) + " (%rax), " + get_register_for_type(reg, element_type) + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX as long), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(REGREG as long), MOV, element_type);
        }
        elseif (type == LVALUE) {
            //add_to_text_buffer(text_buffer, "\tlea" + get_word_size(get_size(element_type)) + " (%rax), " + get_register_for_type(reg, element_type) + "\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(REGREG as long), MOV, LONG_VARIABLE);
            // Im not sure this ^^^ is correct
        }


        //add_to_text_buffer(text_buffer, "\taddl $1, 8(%r12)\n");
        add_instruction(text_buffer, make_imm(1 as long), make_mem(make_reg(R12 as long), 0 as Operand*, 0, 8, REGISTER_RELATIVE), ADD, INT_VARIABLE);
        dealign_stack(text_buffer, alignment_offset);
        return element_type;
    }
    else {
        if (type == LVALUE) {
            print("User defined function call is not allowed as lvalue\n");
        }


        let function_signature = get_signature(function_registry, name);
        let arguments_size = 0;
        for (let i = 0; i < function_signature->parameters.len(); i = i + 1) {
            arguments_size = arguments_size + get_size(function_signature->parameters[i]->type);
        }

        let alignment_offset = align_stack(text_buffer, rsp_offset - arguments_size);

        if (function_signature->parameters.len() != function_call_node->arguments.len()) {
            print("Mismatch in number of arguments. Expected " + int_to_str(function_signature->parameters.len()) + ", got " + int_to_str(function_call_node->arguments.len()) + "\n");
        }

        for (let i = 0; i < function_call_node->arguments.len(); i = i + 1) {
            let argument = function_call_node->arguments[i];
            let argument_type = compile_expression_into_register(text_buffer, argument, stack_frame, 'a', RVALUE);

            let size = get_size(argument_type);
            let word_size = get_word_size(size);

            if (size != get_size(function_signature->parameters[i]->type)) {
                print("Mismatch in argument size. Expected " + debug_variable_type_name(function_signature->parameters[i]->type) + ", got " + debug_variable_type_name(argument_type) + "\n");
            }

            //add_to_text_buffer(text_buffer, "\tsubq $" + int_to_str(size) + ", %rsp\n");
            add_instruction(text_buffer, make_imm(size as long), make_reg(RSP as long), SUB, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmov" + word_size + " " + get_register_for_type('a', argument_type) + ", (%rsp)\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_mem(make_reg(RSP as long), 0 as Operand*, 0, 0, REGISTER_RELATIVE), MOV, argument_type);

            rsp_offset = rsp_offset - size;
        }

        let return_type = function_signature->return_type;
        //add_to_text_buffer(text_buffer, "\tcall " + name + "\n");
        add_instruction(text_buffer, make_label(name), 0 as Operand*, CALL, VOID);

        if (return_type != VOID) {
            //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(return_type)) + " " + get_register_for_type('a', return_type) + ", " + get_register_for_type(reg, return_type) + "\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(REGREG as long), MOV, return_type);
        }

        for (let i = 0; i < function_signature->parameters.len(); i = i + 1) {
            let argument_size = get_size(function_signature->parameters[i]->type);
            //add_to_text_buffer(text_buffer, "\taddq $" + int_to_str(argument_size) + ", %rsp\n");
            add_instruction(text_buffer, make_imm(argument_size as long), make_reg(RSP as long), ADD, LONG_VARIABLE);
            rsp_offset = rsp_offset + argument_size;
        }

        dealign_stack(text_buffer, alignment_offset);
        return return_type;
    }
}


fn compile_expression_into_register(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, reg: char, type: int): int {
    let REGREG = RAX; // VERY TEMPORARY TODO TODO Remove this
    if (reg == 'a') {
        REGREG = RAX;
    }
    elseif (reg == 'b') {
        REGREG = RBX;
    }
    elseif (reg == 'd') {
        REGREG = RDX;
    }
    else {
        print("Unknown register for expression into register " + reg + "\n");
    }
    if (node->type == EXPRESSION_INT) {
        if (type == LVALUE) {
            print("Int expression is not allowed as lvalue\n");
        }
        let register_name = get_register_for_size(reg, 4);
        //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str((node->node as IntNode*)->value) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_imm((node->node as IntNode*)->value as long), make_reg(REGREG as long), MOV, INT_VARIABLE);
        return INT_VARIABLE;
    }
    elseif (node->type == EXPRESSION_LONG) {
        if (type == LVALUE) {
            print("Long expression is not allowed as lvalue\n");
        }
        let register_name = get_register_for_size(reg, 8);
        //add_to_text_buffer(text_buffer, "\tmovq $" + long_to_str((node->node as LongNode*)->value) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_imm((node->node as LongNode*)->value as long), make_reg(REGREG as long), MOV, LONG_VARIABLE);
        return LONG_VARIABLE;
    }
    elseif (node->type == EXPRESSION_TRUE) {
        if (type == LVALUE) {
            print("True expression is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tmovb $1, " + get_register_for_type(reg, BOOL_VARIABLE) + "\n");
        add_instruction(text_buffer, make_imm(1 as long), make_reg(REGREG as long), MOV, BOOL_VARIABLE);

        return BOOL_VARIABLE;
    }
    elseif (node->type == EXPRESSION_FALSE) {
        if (type == LVALUE) {
            print("False expression is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tmovb $0, " + get_register_for_type(reg, BOOL_VARIABLE) + "\n");
        add_instruction(text_buffer, make_imm(0 as long), make_reg(REGREG as long), MOV, BOOL_VARIABLE);

        return BOOL_VARIABLE;
    }
    elseif (node->type == EXPRESSION_VARIABLE) {
        let name = (node->node as VariableNode*)->name;
        let variable = get_variable(stack_frame, name);
        if (variable) {
            let variable_type = variable->type;
            if (type == LVALUE) { 
                variable_type = to_pointer(variable_type);
            }
            let register_name = get_register_for_type(reg, variable_type);
            let word_size = get_word_size(get_size(variable_type));
            if (type == RVALUE) {
                //add_to_text_buffer(text_buffer, "\tmov" + word_size + " " + variable->offset.int_to_str() + "(%rbp), " + register_name + "\n");
                add_instruction(text_buffer, make_mem(make_reg(RBP as long), 0 as Operand*, 0, variable->offset, REGISTER_RELATIVE), make_reg(REGREG as long), MOV, variable_type);
            }
            elseif (type == LVALUE) {
                //add_to_text_buffer(text_buffer, "\tleaq" + " " + variable->offset.int_to_str() + "(%rbp), " + register_name + "\n");
                add_instruction(text_buffer, make_mem(make_reg(RBP as long), 0 as Operand*, 0, variable->offset, REGISTER_RELATIVE), make_reg(REGREG as long), LEA, LONG_VARIABLE);
            }
            return variable_type;
        }
        else {
            let global_variable = get_global_variable(global_scope, name);
            let variable_type = UNDEFINED_VARIABLE;
            if (global_variable) {
                variable_type = global_variable->type;
                if (type == LVALUE) {
                    variable_type = to_pointer(variable_type);
                }
                let register_name = get_register_for_type(reg, variable_type);
                let word_size = get_word_size(get_size(variable_type));
                if (type == RVALUE) {
                    if (is_const(variable_type)) {
                        variable_type = variable_type ^ (1 << 24);
                        if (variable_type == INT_VARIABLE) {
                            //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str(*(global_variable->value as int*)) + ", " + register_name + "\n");
                        }
                        elseif (variable_type == LONG_VARIABLE) {
                            //add_to_text_buffer(text_buffer, "\tmovq $" + long_to_str(*(global_variable->value as long*)) + ", " + register_name + "\n");
                        }
                        else {
                            print("Unknown const variable type " + debug_variable_type_name(variable_type) + "\n");
                        }
                        add_instruction(text_buffer, make_imm(*(global_variable->value as int*) as long), make_reg(REGREG as long), MOV, variable_type);
                    }
                    else {
                        //add_to_text_buffer(text_buffer, "\tmov" + word_size + " ." + global_variable->name + "(%rip), " + register_name + "\n");
                        add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(REGREG as long), MOV, variable_type);
                    }
                }
                elseif (type == LVALUE) {
                    if (is_const(variable_type)) {
                        print("Const variables cannot be lvalues\n");
                    }
                    //add_to_text_buffer(text_buffer, "\tleaq" + " ." + global_variable->name + "(%rip), " + register_name + "\n");
                    add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(REGREG as long), LEA, LONG_VARIABLE);
                }
            }
            else {
                print("Global variable " + name + " not found\n");
            }
            return variable_type;
        }
    }
    elseif (node->type == EXPRESSION_BINARY) {
        if (type == LVALUE) {
            print("Binary expression is not allowed as lvalue\n");
        }
        let expression_type = compile_binary_expression(text_buffer, node, stack_frame);
        let register_name = get_register_for_type(reg, expression_type);
        //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(expression_type)) + " " + get_register_for_type('a', expression_type) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_reg(RAX as long), make_reg(REGREG as long), MOV, expression_type);

        return expression_type;
    }
    elseif (node->type == EXPRESSION_UNARY) {
        let expression_type = compile_unary_expression(text_buffer, node, stack_frame, type);
        let register_name = get_register_for_type(reg, expression_type);
        //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(expression_type)) + " " + get_register_for_type('a', expression_type) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_reg(RAX as long), make_reg(REGREG as long), MOV, expression_type);
        return expression_type;
    }
    elseif (node->type == EXPRESSION_STRING_LITERAL) {
        if (type == LVALUE) {
            print("String literal is not allowed as lvalue\n");
        }
        let string_node = (node->node as StringLiteralNode*)->name;
        let global_variable = get_global_variable(global_scope, string_node);
        let register_name = get_register_for_type(reg, global_variable->type);
        //add_to_text_buffer(text_buffer, "\tleaq ." + global_variable->name + "(%rip), " + register_name + "\n");
        add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(REGREG as long), LEA, LONG_VARIABLE);
        return global_variable->type;
    }
    elseif (node->type == EXPRESSION_CHAR) {
        if (type == LVALUE) {
            print("Char is not allowed as lvalue\n");
        }
        let char_node = (node->node as CharNode*)->name;
        let global_variable = get_global_variable(global_scope, char_node);
        let register_name = get_register_for_type(reg, global_variable->type);
        //add_to_text_buffer(text_buffer, "\tmovb ." + global_variable->name + "(%rip), " + register_name + "\n");
        add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(REGREG as long), MOV, CHAR_VARIABLE);
        return global_variable->type;
    }
    elseif (node->type == EXPRESSION_FUNCTION_CALL) {
        let return_type = compile_function_call(node, text_buffer, stack_frame, reg, type);
        if (return_type == VOID) {
            print("Can't assign to void\n");
        }
        return return_type;
    }
    elseif (node->type == EXPRESSION_NEW) {
        if (type == LVALUE) {
            print("New is not allowed as lvalue\n");
        }
        let new_node = (node->node as NewNode*);
        let node_type = new_node->type;
        let alignment_offset = align_stack(text_buffer, rsp_offset);

        if (is_pointer(node_type)) {
            // TODO: put malloc in other c functions in special emit stdlib functions
            let element_type = dereference_type(node_type);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type)) + ", %rdi\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_label("malloc"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $0, %rsi\n");
            add_instruction(text_buffer, make_imm(0 as long), make_reg(RSI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type)) + ", %rdx\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) as long), make_reg(RDX as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall memset\n");
            add_instruction(text_buffer, make_label("memset"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, " + get_register_for_type(reg, node_type) + "\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(REGREG as long), MOV, node_type);
        }
        elseif (is_array(node_type)) {
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(16) + ", %rdi\n");
            add_instruction(text_buffer, make_imm(16 as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_label("malloc"), 0 as Operand*, CALL, VOID);

            let element_type = dereference_type(dereference_type(node_type));
            let base_capacity = 4;
            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rbx\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(RBX as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovl $0, " + int_to_str(8) + "(%rbx)\n");
            add_instruction(text_buffer, make_imm(0 as long), make_mem(make_reg(RBX as long), 0 as Operand*, 0, 8, REGISTER_RELATIVE), MOV, INT_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str(base_capacity) + ", " + int_to_str(12) + "(%rbx)\n");
            add_instruction(text_buffer, make_imm(base_capacity as long), make_mem(make_reg(RBX as long), 0 as Operand*, 0, 12, REGISTER_RELATIVE), MOV, INT_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type) * base_capacity) + ", %rdi\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) * base_capacity as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_label("malloc"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $0, %rsi\n");
            add_instruction(text_buffer, make_imm(0 as long), make_reg(RSI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type) * base_capacity) + ", %rdx\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) * base_capacity as long), make_reg(RDX as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall memset\n");
            add_instruction(text_buffer, make_label("memset"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, " + int_to_str(0) + "(%rbx)\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_mem(make_reg(RBX as long), 0 as Operand*, 0, 0, REGISTER_RELATIVE), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq %rbx, " + get_register_for_type(reg, node_type) + "\n");
            add_instruction(text_buffer, make_reg(RBX as long), make_reg(REGREG as long), MOV, LONG_VARIABLE);
        }
        else {
            print("New keyword can only be used to create pointers and arrays\n");
        }
        dealign_stack(text_buffer, alignment_offset);
        return node_type;
    }
    elseif (node->type == EXPRESSION_ARROW || node->type == EXPRESSION_DOUBLE_COLON) {
        let access_node = (node->node as AccessNode*);
        let lrtype = RVALUE;
        if (node->type == EXPRESSION_DOUBLE_COLON) {
            lrtype = LVALUE;
        }
        let left_type = compile_expression_into_register(text_buffer, access_node->left, stack_frame, 'a', lrtype);
        let pointer_register_name = get_register_for_type('a', left_type);
        if (!is_pointer(left_type)) {
            print("Expected pointer type, got " + debug_variable_type_name(left_type) + "\n");
        }

        left_type = dereference_type(left_type);
        if (!(!is_pointer(left_type) && !is_array(left_type) && is_struct(left_type))) {
            print("Expected struct type, got " + debug_variable_type_name(left_type) + "\n");
        }
        let struct_definition = get_struct_with_index(struct_registry, left_type ^ (1 << 7));
        let member = get_struct_member(struct_definition, (access_node->member->node as StructMemberNode*)->name);
        let member_type = member->type;
        if (type == LVALUE) {
            member_type = to_pointer(member_type);
        }
        let member_offset = member->offset;
        let register_name = get_register_for_type(reg, member_type);
        if (type == RVALUE) {
            let word_size = get_word_size(get_size(member_type));
            //add_to_text_buffer(text_buffer, "\tmov" + word_size + " " + int_to_str(member_offset) + "(" + pointer_register_name + "), " + register_name + "\n");
            add_instruction(text_buffer, make_mem(make_reg(pointer_register_name as long), 0 as Operand*, 0, member_offset, REGISTER_RELATIVE), make_reg(REGREG as long), MOV, member_type);
        }
        elseif (type == LVALUE) {
            //add_to_text_buffer(text_buffer, "\tleaq" + " " + int_to_str(member_offset) + "(" + pointer_register_name + "), " + register_name + "\n");
            add_instruction(text_buffer, make_mem(make_reg(pointer_register_name as long), 0 as Operand*, 0, member_offset, REGISTER_RELATIVE), make_reg(REGREG as long), LEA, LONG_VARIABLE);
        }
        return member_type;
    }
    elseif (node->type == EXPRESSION_INDEX) {
        let index_node = (node->node as IndexNode*);
        let left_type = compile_expression_into_register(text_buffer, index_node->left, stack_frame, 'a', RVALUE);
        if (left_type != STRING_VARIABLE && !is_array(left_type) && !is_pointer(left_type)) {
            print("Expected string, array or pointer type, got " + debug_variable_type_name(left_type) + "\n");
        }
        if (is_array(left_type)) {
            //add_to_text_buffer(text_buffer, "\tmovq (%rax), %rax\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX as long), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(RAX as long), MOV, LONG_VARIABLE);
        }

        let element_type: int;
        if (is_array(left_type))  {
            element_type = dereference_type(dereference_type(left_type));
        }
        elseif (is_pointer(left_type)) {
            element_type = dereference_type(left_type);
        }
        else {
            element_type = CHAR_VARIABLE;
        }

        if (index_node->index->type != EXPRESSION_RANGE) {
            //add_to_text_buffer(text_buffer, "\tpushq %rax\n");
            add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, PUSH, LONG_VARIABLE);
            rsp_offset = rsp_offset - 8;
            let index_type = compile_expression_into_register(text_buffer, index_node->index, stack_frame, 'd', RVALUE);

            if (index_type != INT_VARIABLE && index_type != LONG_VARIABLE) {
                print("Expected int type, got " + debug_variable_type_name(index_type) + "\n");
            }
            //add_to_text_buffer(text_buffer, "\tpopq %rax\n");
            add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, POP, LONG_VARIABLE);
            rsp_offset = rsp_offset + 8;

            //add_to_text_buffer(text_buffer, "\tleaq (%rax, %rdx, " + int_to_str(get_size(element_type)) + "), %rax\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX as long), make_reg(RDX as long), get_size(element_type), 0, REGISTER_INDEXED), make_reg(RAX as long), LEA, LONG_VARIABLE);
            if (type == LVALUE) {
                element_type = to_pointer(element_type);
            }
            let register_name = get_register_for_type(reg, element_type);
            let word_size = get_word_size(get_size(element_type));
            if (type == RVALUE) {
                //add_to_text_buffer(text_buffer, "\tmov" + word_size + " (%rax), " + register_name + "\n");
                add_instruction(text_buffer, make_mem(make_reg(RAX as long), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(REGREG as long), MOV, element_type);
            } elseif (type == LVALUE) {
                //add_to_text_buffer(text_buffer, "\tmovq %rax, " + register_name + "\n");
                add_instruction(text_buffer, make_reg(RAX as long), make_reg(REGREG as long), MOV, element_type);
            }
            return element_type;
        }
        else {
            if (is_array(left_type) || is_pointer(left_type)) {
                print("NOT CURRENTLY SUPPORTED\n");
            }

            let range_node = (index_node->index->node as RangeNode*);
            //add_to_text_buffer(text_buffer, "\tpushq %rax\n");
            add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, PUSH, LONG_VARIABLE);
            rsp_offset = rsp_offset - 8;
            let left_index_type = compile_expression_into_register(text_buffer, range_node->left, stack_frame, 'a', RVALUE);

            if (left_index_type != INT_VARIABLE && left_index_type != LONG_VARIABLE) {
                print("Expected int type, got " + debug_variable_type_name(left_index_type) + "\n");
            }
            if (left_index_type == INT_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovslq %eax, %r12\n");
                add_instruction(text_buffer, make_reg(RAX as long), make_reg(R12 as long), encode_sizes_in_opcode(MOVS, INT_VARIABLE, LONG_VARIABLE), VOID);
            }
            elseif (left_index_type == LONG_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovq %rax, %r12\n");
                add_instruction(text_buffer, make_reg(RAX as long), make_reg(R12 as long), MOV, LONG_VARIABLE);
            }

            let right_index_type = compile_expression_into_register(text_buffer, range_node->right, stack_frame, 'a', RVALUE);
            if (right_index_type != INT_VARIABLE && right_index_type != LONG_VARIABLE) {
                print("Expected int type, got " + debug_variable_type_name(right_index_type) + "\n");
            }

            if (right_index_type == INT_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovslq %eax, %r13\n");
                add_instruction(text_buffer, make_reg(RAX as long), make_reg(R13 as long), encode_sizes_in_opcode(MOVS, INT_VARIABLE, LONG_VARIABLE), VOID);
            }
            elseif (right_index_type == LONG_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovq %rax, %r13\n");
                add_instruction(text_buffer, make_reg(RAX as long), make_reg(R13 as long), MOV, LONG_VARIABLE);
            }

            //add_to_text_buffer(text_buffer, "\tpopq %rax\n");
            add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, POP, LONG_VARIABLE);
            rsp_offset = rsp_offset + 8;

            //add_to_text_buffer(text_buffer, "\tsubq %r12, %r13\n");
            add_instruction(text_buffer, make_reg(R12 as long), make_reg(R13 as long), SUB, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tleaq (%rax, %r12, " + int_to_str(get_size(element_type)) + "), %r14\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX as long), make_reg(R12 as long), get_size(element_type), 0, REGISTER_INDEXED), make_reg(R14 as long), LEA, LONG_VARIABLE);

  
            let alignment_offset = align_stack(text_buffer, rsp_offset);
            //add_to_text_buffer(text_buffer, "\tleaq 1(,%r13, " + int_to_str(get_size(element_type)) + "), %rdi\n");
            add_instruction(text_buffer, make_mem(0 as Operand*, make_reg(R13 as long), get_size(element_type), 1, REGISTER_INDEXED), make_reg(RDI as long), LEA, LONG_VARIABLE);
            add_instruction(text_buffer, make_imm(1 as long), make_reg(RDI as long), ADD, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_label("malloc"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %r13, %rdx\n");
            add_instruction(text_buffer, make_reg(R13 as long), make_reg(RDX as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq %r14, %rsi\n");
            add_instruction(text_buffer, make_reg(R14 as long), make_reg(RSI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_reg(RDI as long), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall memcpy\n");
            add_instruction(text_buffer, make_label("memcpy"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq $0, (%rax, %r13, " + int_to_str(get_size(element_type)) + ")\n");
            add_instruction(text_buffer, make_imm(0 as long), make_mem(make_reg(RAX as long), make_reg(R13 as long), get_size(element_type), 0, REGISTER_INDEXED), MOV, LONG_VARIABLE);
            dealign_stack(text_buffer, alignment_offset);
            return STRING_VARIABLE;
        }
    }
    elseif (node->type == EXPRESSION_AS) {
        let as_node = (node->node as AsNode*);
        let value_type = compile_expression_into_register(text_buffer, as_node->value, stack_frame, reg, RVALUE);
        let cast_type = as_node->type;

        let value_size = get_size(value_type);
        let cast_size = get_size(cast_type);
        if (value_size == cast_size) {
            return cast_type;
        }

        if (cast_size > value_size) {
            //add_to_text_buffer(text_buffer, "\tmovs" + get_word_size(value_size) + get_word_size(cast_size) + " " + get_register_for_type(reg, value_type) + ", " + get_register_for_type(reg, cast_type) + "\n");
            add_instruction(text_buffer, make_reg(REGREG as long), make_reg(REGREG as long), encode_sizes_in_opcode(MOVS, value_type, cast_type), VOID);
        }
        else {
            print("# Narrowing conversion from " + debug_variable_type_name(value_type) + " to " + debug_variable_type_name(cast_type) + "\n");
        }
        return cast_type;
    }
    print("Unknown expression type to put in register " + int_to_str(node->type) + "\n");
    return VOID;
}

fn compile_assign(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, type: int) {
    let assign_node = (node->node as AssignNode*);
    let name = assign_node->name;

    let variable_type = 0;
    if (text_buffer) {
        if (type == STATEMENT_ASSIGN) {
            variable_type = compile_expression_into_register(text_buffer, assign_node->lvalue, stack_frame, 'a', LVALUE);

            //add_to_text_buffer(text_buffer, "\tpushq %rax\n");
            add_instruction(text_buffer, make_reg(RAX as long), 0 as Operand*, PUSH, LONG_VARIABLE);
            rsp_offset = rsp_offset - 8;
        }
    }

    if (assign_node->rvalue) {
        let expression_type: int;

        let rvalue_type = assign_node->rvalue->type;
        if (rvalue_type == EXPRESSION_INT) {
            expression_type = INT_VARIABLE;

            let int_node = (assign_node->rvalue->node as IntNode*);
            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str(int_node->value) + ", %eax\n");
                add_instruction(text_buffer, make_imm(int_node->value as long), make_reg(RAX as long), MOV, INT_VARIABLE);
            }
            else {
                if (assign_node->is_const) {
                    expression_type = to_const(expression_type);
                }
                let intPtr = new int*;
                *intPtr = int_node->value;
                add_global_variable(global_scope, name, intPtr as ptr, expression_type);
            }
        }
        elseif (rvalue_type == EXPRESSION_LONG) {
            expression_type = LONG_VARIABLE;
            let long_node = (assign_node->rvalue->node as LongNode*);
            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tmovq $" + long_to_str(long_node->value) + ", %rax\n");
                add_instruction(text_buffer, make_imm(long_node->value as long), make_reg(RAX as long), MOV, LONG_VARIABLE);
            }
            else {
                if (assign_node->is_const) {
                    expression_type = to_const(expression_type);
                }
                let longPtr = new long*;
                *longPtr = long_node->value; 
                add_global_variable(global_scope, name, longPtr as ptr, expression_type);
            }
        }
        elseif (rvalue_type == EXPRESSION_FUNCTION_CALL) {
            let return_type = compile_function_call(assign_node->rvalue, text_buffer, stack_frame, 'a', RVALUE);
            if (return_type == VOID) {
                print("Can't assign to void\n");
            }
            expression_type = return_type;
        }
        elseif (rvalue_type == EXPRESSION_STRING_LITERAL) {
            expression_type = STRING_VARIABLE;

            let string_node = (assign_node->rvalue->node as StringLiteralNode*);
            let global_variable = get_global_variable(global_scope, string_node->name);

            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tleaq ." + global_variable->name + "(%rip), %rax\n");
                add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(RAX as long), LEA, LONG_VARIABLE);
            }
            else {
                add_global_variable(global_scope, name, global_variable->name as ptr, expression_type);
            }
        }
        elseif (rvalue_type == EXPRESSION_CHAR) {
            let char_node = (assign_node->rvalue->node as CharNode*);
            let global_variable = get_global_variable(global_scope, char_node->name);
            expression_type = CHAR_VARIABLE;
            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tmovb ." + global_variable->name + "(%rip), %al\n");
                add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(RAX as long), MOV, CHAR_VARIABLE);
            }
            else {
                global_variable->name = name;
            }
        }
        elseif (rvalue_type == EXPRESSION_BINARY) {
            expression_type = compile_binary_expression(text_buffer, assign_node->rvalue, stack_frame);
        }
        elseif (rvalue_type == EXPRESSION_UNARY) {
            expression_type = compile_unary_expression(text_buffer, assign_node->rvalue, stack_frame, RVALUE);
        }
        elseif (rvalue_type == EXPRESSION_VARIABLE || rvalue_type == EXPRESSION_INDEX || rvalue_type == EXPRESSION_AS || rvalue_type == EXPRESSION_NEW || rvalue_type == EXPRESSION_ARROW || rvalue_type == EXPRESSION_TRUE || rvalue_type == EXPRESSION_FALSE || rvalue_type == EXPRESSION_DOUBLE_COLON) {
            expression_type = compile_expression_into_register(text_buffer, assign_node->rvalue, stack_frame, 'a', RVALUE);
        }
        else {
            print("Unknown expression type to assign" + int_to_str(rvalue_type) + "\n");
        }



        if ((text_buffer != (0 as ptr)) && (type == STATEMENT_ASSIGN)) {
            variable_type = dereference_type(variable_type);
            if (get_underlying_type(variable_type) != get_underlying_type(expression_type)) {
                if (!(variable_type == PTR_VARIABLE && (is_pointer(expression_type) || is_array(expression_type)))) {
                    print("Implicit conversion not possible. Trying to assign type " + debug_variable_type_name(expression_type) + " to variable type " + debug_variable_type_name(variable_type) + "\n");
                }
            }

            //add_to_text_buffer(text_buffer, "\tpopq %rbx\n");
            add_instruction(text_buffer, make_reg(RBX as long), 0 as Operand*, POP, LONG_VARIABLE);
            rsp_offset = rsp_offset + 8;
            //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(variable_type)) + " " + get_register_for_type('a', variable_type) + ", (%rbx)\n");
            add_instruction(text_buffer, make_reg(RAX as long), make_mem(make_reg(RBX as long), 0 as Operand*, 0, 0, REGISTER_RELATIVE), MOV, variable_type);

        }

        if (text_buffer != (0 as ptr) && type == STATEMENT_LET) {
            let variable_node = get_variable(stack_frame, name);
            if (variable_node) {
                print("Variable named: " + name + " already declared\n");
            }
            variable_node = add_variable(stack_frame, name, expression_type, 0);

            let stack_variable = make_stack(variable_node->offset);
            add_instruction(text_buffer, make_reg(RAX as long), stack_variable, MOV, expression_type);
        }
    }
    else {
        if (assign_node->type == UNDEFINED_VARIABLE) {
            print("Cannot create/assign to a variable because neither the value nor the type was provided\n");
        }

        let zero_buffer = new char[];
        for (let i = 0; i < get_size(assign_node->type); i = i + 1) {
            zero_buffer.append('\0');
        }
        add_global_variable(global_scope, name, (*zero_buffer) as ptr, assign_node->type);
    }
}


fn compile_if_jump(text_buffer: TextBuffer*, if_statement_node: IfStatementNode*, index: int, i: int) {
    if (if_statement_node->else_if_count > i + 1) {
        //add_to_text_buffer(text_buffer, "\tjz .L" + int_to_str(index) + "_elseif_" + int_to_str(i + 1) + "\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(index) + "_elseif_" + int_to_str(i + 1)), 0 as Operand*, JMPZ, VOID);
    }
    elseif (if_statement_node->else_block) {
        //add_to_text_buffer(text_buffer, "\tjz .L" + int_to_str(index) + "_else\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(index) + "_else"), 0 as Operand*, JMPZ, VOID);
    }
    else {
        //add_to_text_buffer(text_buffer, "\tjz .L" + int_to_str(index) + "_end\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(index) + "_end"), 0 as Operand*, JMPZ, VOID);
    }
}

fn compile_statement(text_buffer: TextBuffer*, stack_frame: StackFrame*, statement: AstNode*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) 

fn compile_block(text_buffer: TextBuffer*, stack_frame: StackFrame*, block: AstBlock*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {
    for (let i = 0; i < block->statements.len(); i = i + 1) {
        compile_statement(text_buffer, stack_frame, block->statements[i], curr_func, curr_loop);
    }
}

fn compile_if_block(text_buffer: TextBuffer*, if_block: AstBlock*, stack_frame: StackFrame*, index: int, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {
    let block_stack_frame = new_stack_frame(stack_frame);
    let block_text_buffer = new_text_buffer();


    compile_block(block_text_buffer, block_stack_frame, if_block, curr_func, curr_loop);

    //add_to_text_buffer(block_text_buffer, "\tjmp .L" + int_to_str(index) + "_end\n");
    add_instruction(block_text_buffer, make_label("L" + int_to_str(index) + "_end"), 0 as Operand*, JMP, VOID);

    print_stack_frame_size(text_buffer, block_stack_frame);
    terminate_buffer(block_text_buffer);
    add_to_text_buffer(text_buffer, *(block_text_buffer->buffer));
}

fn compile_if(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {

    let if_statement_node = (node->node as IfStatementNode*);

    let index = get_label_index();

    let conditional_node = if_statement_node->condition;

    let conditional_type = compile_expression_into_register(text_buffer, conditional_node, stack_frame, 'a', RVALUE);
    //add_to_text_buffer(text_buffer, "\tcmp $0, " + get_register_for_type('a', conditional_type) + "\n");
    add_instruction(text_buffer, make_imm(0 as long), make_reg(RAX as long), CMP, conditional_type);
    compile_if_jump(text_buffer, if_statement_node, index, -1);

    compile_if_block(text_buffer, if_statement_node->then_block, stack_frame, index, curr_func, curr_loop);

    for (let i = 0; i < if_statement_node->else_if_count; i = i + 1) {
        let elseif_conditional_node = if_statement_node->else_if_conditions[i];

        add_to_text_buffer(text_buffer, ".L" + int_to_str(index) + "_elseif_" + int_to_str(i) + ":\n");

        let elseif_conditional_type = compile_expression_into_register(text_buffer, elseif_conditional_node, stack_frame, 'a', RVALUE);
        //add_to_text_buffer(text_buffer, "\tcmp $0, " + get_register_for_type('a', elseif_conditional_type) + "\n");
        add_instruction(text_buffer, make_imm(0 as long), make_reg(RAX as long), CMP, elseif_conditional_type);
        compile_if_jump(text_buffer, if_statement_node, index, i);

        compile_if_block(text_buffer, if_statement_node->else_if_blocks[i], stack_frame, index, curr_func, curr_loop);
    }

    if (if_statement_node->else_block) {
        add_to_text_buffer(text_buffer, ".L" + int_to_str(index) + "_else:\n");

        compile_if_block(text_buffer, if_statement_node->else_block, stack_frame, index, curr_func, curr_loop);
    }

    add_to_text_buffer(text_buffer, ".L" + int_to_str(index) + "_end:\n");
}

fn compile_return(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*): int {
    let return_node = (node->node as ReturnNode*);

    if (curr_func == (0 as FunctionSignature*)) {
        print("Return called from outside of a function\n");
    }

    if (return_node->value == (0 as AstNode*)) {
        //add_to_text_buffer(text_buffer, "\tleave\n");
        add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, LEAVE, VOID);
        //add_to_text_buffer(text_buffer, "\tret\n");
        add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, RET, VOID);
        return VOID;
    }

    let return_type = curr_func->return_type;
    let return_expression_type = compile_expression_into_register(text_buffer, return_node->value, stack_frame, 'a', RVALUE);

    if (get_underlying_type(return_type) != get_underlying_type(return_expression_type)) {
        print("Type in return statement doesnt match the return type of function " + curr_func->name + ". Expected " + debug_variable_type_name(return_type) + ", got " + debug_variable_type_name(return_expression_type) + "\n");
        print("Underlying types are: " + debug_variable_type_name(get_underlying_type(return_type)) + " and " + debug_variable_type_name(get_underlying_type(return_expression_type)) + "\n");
    }

    //add_to_text_buffer(text_buffer, "\tleave\n");
    add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, LEAVE, VOID);
    //add_to_text_buffer(text_buffer, "\tret\n");
    add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, RET, VOID);
    return return_type;
}

fn compile_function(node: AstNode*, stack_frame: StackFrame*) {
    let function_node = (node->node as FunctionNode*);
    if ((function_node->body) == (0 as ptr)) {
        return;
    }

    let function_stack_frame = new_stack_frame(0 as StackFrame*);
    let function_text_buffer = new_text_buffer();
    let function_signature = function_node->function_signature;

    let name = function_node->name;
    if (name == "main") {
        add_variable(function_stack_frame, "argc", INT_VARIABLE, 0);
        add_variable(function_stack_frame, "argv", to_pointer(to_pointer(CHAR_VARIABLE)), 0);
    }
    for (let i = 0; i < function_signature->parameters.len(); i = i + 1) {
        let parameter = function_signature->parameters[i];
        add_variable(function_stack_frame, parameter->name, parameter->type, parameter->offset);
    }
    for (let i = 0; i < function_node->body->statements.len(); i = i + 1) {
        if (function_node->body->statements[i]->type == STATEMENT_RETURN) {
            let return_type = compile_return(function_text_buffer, function_node->body->statements[i], function_stack_frame, function_signature);
            if (get_underlying_type(return_type) != get_underlying_type(function_signature->return_type)) {
                print("Return type mismatch in function " + function_node->name + ". Expected " + debug_variable_type_name(function_signature->return_type) + ", got " + debug_variable_type_name(return_type) + "\n");
                print("Underlying types are: " + debug_variable_type_name(get_underlying_type(function_signature->return_type)) + " and " + debug_variable_type_name(get_underlying_type(return_type)) + "\n");
            }
        }
        else {
            compile_statement(function_text_buffer, function_stack_frame, function_node->body->statements[i], function_signature, 0 as LoopSignature*);
        }
    }

    print(".globl " + name + "\n");
    print(name + ":\n");
    print("\tpushq %rbp\n");
    print("\tmovq %rsp, %rbp\n");
    rsp_offset = 0;

    if (name == "main") {
        rsp_offset = -16;
        print("\tsubq $16, %rsp\n");
        print("\tmovl %edi, -4(%rbp)\n");
        print("\tmovq %rsi, -12(%rbp)\n");
    }

    print_stack_frame_size(0 as TextBuffer*, function_stack_frame);
    terminate_buffer(function_text_buffer);
    print(*(function_text_buffer->buffer));

    print("\tleave\n\tret\n");
}

fn compile_break(text_buffer: TextBuffer*, stack_frame: StackFrame*, curr_loop: LoopSignature*) {
    if (curr_loop == (0 as LoopSignature*)) {
        print("Break called from outside of a loop\n");
    }

    if (curr_loop->type == STATEMENT_FOR) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_for_end\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_for_end"), 0 as Operand*, JMP, VOID);
    }
    elseif (curr_loop->type == STATEMENT_WHILE) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_while_end\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_while_end"), 0 as Operand*, JMP, VOID);
    }
    else {
        print("Unknown loop type " + int_to_str(curr_loop->type) + "\n");
    }
}

fn compile_continue(text_buffer: TextBuffer*, stack_frame: StackFrame*, curr_loop: LoopSignature*) {
    if (curr_loop == (0 as LoopSignature*)) {
        print("Continue called from outside of a loop\n");
    }
    
    if (curr_loop->type == STATEMENT_FOR) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_for_inc\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_for_inc"), 0 as Operand*, JMP, VOID);
    }
    elseif (curr_loop->type == STATEMENT_WHILE) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_while_start\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_for_inc"), 0 as Operand*, JMP, VOID);
    }
    else {
        print("Unknown loop type " + int_to_str(curr_loop->type) + "\n");
    }
}

fn compile_while(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*) {
    let while_statement_node = (node->node as WhileStatementNode*);

    let while_stack_frame = new_stack_frame(stack_frame);
    let while_text_buffer = new_text_buffer();

    let loop_signature = new LoopSignature*;

    let index = get_label_index();
    loop_signature->type = node->type;
    loop_signature->index = index;

    add_to_text_buffer(while_text_buffer, ".L" + int_to_str(index) + "_while_start:\n");

    let condition_type = compile_expression_into_register(while_text_buffer, while_statement_node->condition, while_stack_frame, 'a', RVALUE);

    //add_to_text_buffer(while_text_buffer, "\tcmp $0, " + get_register_for_type('a', condition_type) + "\n");
    add_instruction(while_text_buffer, make_imm(0 as long), make_reg(RAX as long), CMP, condition_type);
    //add_to_text_buffer(while_text_buffer, "\tjz .L" + int_to_str(index) + "_while_end\n");
    add_instruction(while_text_buffer, make_label("L" + int_to_str(index) + "_while_end"), 0 as Operand*, JMPZ, VOID);

    compile_block(while_text_buffer, while_stack_frame, while_statement_node->body, curr_func, loop_signature);

    //add_to_text_buffer(while_text_buffer, "\tjmp .L" + int_to_str(index) + "_while_start\n");
    add_instruction(while_text_buffer, make_label("L" + int_to_str(index) + "_while_start"), 0 as Operand*, JMP, VOID);

    add_to_text_buffer(while_text_buffer, ".L" + int_to_str(index) + "_while_end:\n");

    print_stack_frame_size(text_buffer, while_stack_frame);
    terminate_buffer(while_text_buffer);
    add_to_text_buffer(text_buffer, *(while_text_buffer->buffer));
}
    
fn compile_for(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*) {
    let for_statement_node = (node->node as ForStatementNode*);
    
    let for_stack_frame = new_stack_frame(stack_frame);
    let for_text_buffer = new_text_buffer();

    let init_node = for_statement_node->initializer;
    let condition_node = for_statement_node->condition;
    let increment_node = for_statement_node->increment;
    let body_block = for_statement_node->body;

    compile_statement(for_text_buffer, for_stack_frame, init_node, curr_func, 0 as LoopSignature*);

    let index = get_label_index();
    let loop_signature = new LoopSignature*;
    loop_signature->type = node->type;
    loop_signature->index = index;

    add_to_text_buffer(for_text_buffer, ".L" + int_to_str(index) + "_for_start:\n");

    let condition_type = compile_expression_into_register(for_text_buffer, condition_node, for_stack_frame, 'a', RVALUE);
    //add_to_text_buffer(for_text_buffer, "\tcmp $0, " + get_register_for_type('a', condition_type) + "\n");
    add_instruction(for_text_buffer, make_imm(0 as long), make_reg(RAX as long), CMP, condition_type);
    //add_to_text_buffer(for_text_buffer, "\tjz .L" + int_to_str(index) + "_for_end\n");
    add_instruction(for_text_buffer, make_label("L" + int_to_str(index) + "_for_end"), 0 as Operand*, JMPZ, VOID);

    compile_block(for_text_buffer, for_stack_frame, body_block, curr_func, loop_signature);

    add_to_text_buffer(for_text_buffer, ".L" + int_to_str(index) + "_for_inc:\n");
    compile_statement(for_text_buffer, for_stack_frame, increment_node, curr_func, loop_signature);
    //add_to_text_buffer(for_text_buffer, "\tjmp .L" + int_to_str(index) + "_for_start\n");
    add_instruction(for_text_buffer, make_label("L" + int_to_str(index) + "_for_start"), 0 as Operand*, JMP, VOID);

    add_to_text_buffer(for_text_buffer, ".L" + int_to_str(index) + "_for_end:\n");

    print_stack_frame_size(text_buffer, for_stack_frame);
    terminate_buffer(for_text_buffer);
    add_to_text_buffer(text_buffer, *(for_text_buffer->buffer));
}

fn compile_file(file_name: str)

fn compile_statement(text_buffer: TextBuffer*, stack_frame: StackFrame*, statement: AstNode*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {

    if (statement->type == STATEMENT_LET) {
        compile_assign(text_buffer, statement, stack_frame, statement->type);
    }
    elseif (statement->type == STATEMENT_ASSIGN) {
        compile_assign(text_buffer, statement, stack_frame, statement->type);
    }
    elseif (statement->type == STATEMENT_IF) {
        compile_if(text_buffer, statement, stack_frame, curr_func, curr_loop);
    }
    elseif (statement->type == STATEMENT_FUNCTION) {
        if (text_buffer != (0 as ptr)) {
            print("Nested functions are not supported\n");
        }
        compile_function(statement, stack_frame);
    }
    elseif (statement->type == STATEMENT_RETURN) {
        compile_return(text_buffer, statement, stack_frame, curr_func);
    }
    elseif (statement->type == STATEMENT_BREAK) {
        compile_break(text_buffer, stack_frame, curr_loop);
    }
    elseif (statement->type == STATEMENT_CONTINUE) {
        compile_continue(text_buffer, stack_frame, curr_loop);
    }
    elseif (statement->type == EXPRESSION_FUNCTION_CALL) {
        compile_function_call(statement, text_buffer, stack_frame, 'a', RVALUE);
    }
    elseif (statement->type == STATEMENT_WHILE) {
        compile_while(text_buffer, statement, stack_frame, curr_func);
    }
    elseif (statement->type == STATEMENT_FOR) {
        compile_for(text_buffer, statement, stack_frame, curr_func);
    }
    elseif (statement->type == STATEMENT_STRUCT || statement->type == STATEMENT_NONE) {

    }
    elseif (statement->type == STATEMENT_IMPORT) {
        let import_node = (statement->node as ImportNode*);
        compile_file(import_node->filename);
    }
    else {
        print("Unknown statement type " + int_to_str(statement->type) + "\n");
    }
}
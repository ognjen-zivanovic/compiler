const {
    X86_64,
    AARCH64,
};

let current_target: int;

struct TextBuffer {
    buffer: char[],
}

fn new_text_buffer(): TextBuffer* {
    let text_buffer = new TextBuffer*;
    text_buffer->buffer = new char[];
    return text_buffer;
}

fn delete_text_buffer(text_buffer: TextBuffer*) {
    if (text_buffer) {
        delete[] text_buffer->buffer;
        delete text_buffer;
    }
}

fn add_to_text_buffer(buffer: TextBuffer*, text: str) {
    if (buffer) {
        let text_length = len(text);
        for (let i = 0; i < text_length; i = i + 1) {
            buffer->buffer.append(text[i]);
        }
    }
    else {
        print(text);
    }
}

fn terminate_buffer(buffer: TextBuffer*) {
    buffer->buffer.append('\0');
}

fn print_loc(text_buffer: TextBuffer*, loc: int) {
    let l = 0;
    let r = line_positions.len() - 1;
    let i = -1;
    while (l <= r) {
        let m = (l + r) / 2;
        if (loc < line_positions[m]) {
            r = m - 1;
        }
        else {
            l = m + 1;
            i = m;
        }
    }
    let line_number = i + 1;
    let line_position = loc - line_positions[i];
    add_to_text_buffer(text_buffer, ".loc " + file_index.int_to_str() + " " + line_number.int_to_str() + " " + line_position.int_to_str() + "\n");
}


const {
    REG,
    IMM,
    LABEL,
    STDLIB_LABEL,
    RELATIVE_LABEL,
    MEM,
};

const {
    MOV,
    STORE,
    LOAD,
    LEA,
    ADD,
    SUB,
    IMUL,
    IDIV,
    SAL,
    SAR,
    AND,
    OR,
    XOR,
    CMP,
    TESTZ, // find better name
    NEG,
    NOT,
    CALL,
    PUSH,
    POP,
    SETE,
    SETNE,
    MOVS,
    MOD,
    CMPSETL,
    CMPSETLE,
    CMPSETG,
    CMPSETGE,
    CMPSETE,
    CMPSETNE,
    JMP,
    JMPZ,
    LEAVE,
    RET,
    LOADGLOBL,
    LEAGLOBL,
};

const: long {
    RAX,
    RBX,
    RCX,
    RDX,
    RSI,
    RDI,
    RBP,
    RSP,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
};

const {
    REGISTER_RELATIVE,
    REGISTER_INDEXED,
};

struct Operand {
    value: long,
    type: int,
}

struct Instruction {
    src: Operand*,
    dest: Operand*,
    opcode: int,
    type: int,
}

let instructions: Instruction*[];

fn make_reg(reg: long): Operand* {
    let operand = new Operand*;
    operand->value = reg;
    operand->type = REG;
    return operand;
}


fn make_imm(imm: long): Operand* {
    let operand = new Operand*;
    operand->value = imm;
    operand->type = IMM;
    return operand;
}

fn make_label(label: ptr): Operand* {
    let operand = new Operand*;
    operand->value = label as long;
    operand->type = LABEL;
    return operand;
}

fn make_stdlib_label(label: str): Operand* {
    let operand = new Operand*;
    operand->value = label as long;
    operand->type = STDLIB_LABEL;
    return operand;
}

fn make_relative_label(label: str): Operand* {
    let operand = new Operand*;
    operand->value = label as long;
    operand->type = RELATIVE_LABEL;
    return operand;
}

fn make_mem(base_register: Operand*, index_register: Operand*, scale: int, offset: int, mode: int): Operand* {
    // be careful with the long casts, the value needs to be cast to long before the bitwise operations
    let operand = new Operand*;
    operand->value = (offset & (((1 as long) << 32) - 1));
    operand->value = operand->value | ((scale as long & 15) << 32);
    if (index_register) {
        operand->value = operand->value | ((index_register->value & 31) << 36);
    } else {
        operand->value = operand->value | (31 as long << 36);
    }
    if (base_register) {
        operand->value = operand->value | ((base_register->value & 31) << 41);
    } else {
        operand->value = operand->value | (31 as long << 41);
    }
    operand->value = operand->value | ((mode & 3) as long << 46);
    operand->type = MEM;
    return operand;
}

fn make_stack(offset: int): Operand* {
    return make_mem(make_reg(RBP), 0 as Operand*, 0, offset, REGISTER_RELATIVE);
}

fn emit_instruction(text_buffer: TextBuffer*, instruction: Instruction*)

fn add_instruction(text_buffer: TextBuffer*, src: Operand*, dest: Operand*, opcode: int, type: int) {
    let instruction = new Instruction*;
    instruction->src = src;
    instruction->dest = dest;
    instruction->opcode = opcode;
    instruction->type = type;
    instructions.append(instruction);
    emit_instruction(text_buffer, instruction);
}

let register_names_byte: str[];
let register_names_dword: str[];
let register_names_qword: str[];

fn emit_operand_x86(text_buffer: TextBuffer*, operand: Operand*, size: int) {
    if (operand->type == REG) {
        if (operand->value == 31) {
            return;
        }
        if (size == 1) {
            add_to_text_buffer(text_buffer, register_names_byte[operand->value]);
        }
        elseif (size == 4) {
            add_to_text_buffer(text_buffer, register_names_dword[operand->value]);
        }
        elseif (size == 8) {
            add_to_text_buffer(text_buffer, register_names_qword[operand->value]);
        }
        else {
            error("Unknown size for operand " + int_to_str(size) + "\n");
        }
    }
    elseif (operand->type == MEM) {
        let mode = (operand->value >> 46) & 3;
        let offset = (operand->value & (((1 as long) << 32) - 1)) as int;
        let base_register = (operand->value >> 41) & 31;
        let index_register = (operand->value >> 36) & 31;
        let scale = (operand->value >> 32) & 15;

        if (mode == REGISTER_RELATIVE) {
            if (offset != 0) {
                add_to_text_buffer(text_buffer, offset.int_to_str());
            }
            add_to_text_buffer(text_buffer, "(");
            emit_operand_x86(text_buffer, make_reg(base_register), 8);
            add_to_text_buffer(text_buffer, ")");
        }
        elseif (mode == REGISTER_INDEXED) {
            add_to_text_buffer(text_buffer, "(");
            emit_operand_x86(text_buffer, make_reg(base_register), 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_x86(text_buffer, make_reg(index_register), 8);
            add_to_text_buffer(text_buffer, ", ");
            add_to_text_buffer(text_buffer, long_to_str(scale));
            add_to_text_buffer(text_buffer, ")");
        }
        else {
            error("Unknown mode of mem operand" + int_to_str(mode as int) + "\n");
        }
    }
    elseif (operand->type == IMM) {
        add_to_text_buffer(text_buffer, "$" + long_to_str(operand->value));
    }
    elseif (operand->type == LABEL || operand->type == STDLIB_LABEL) {
        add_to_text_buffer(text_buffer, operand->value as str);
    }
    elseif (operand->type == RELATIVE_LABEL) {
        add_to_text_buffer(text_buffer, "." + operand->value as str + "(%rip)");
    }
    else {
        error("Unknown operand type " + int_to_str(operand->type) + "\n");
    }
}

fn add_size_letter(text_buffer: TextBuffer*, size: int) {
    if (size == 1) {
        add_to_text_buffer(text_buffer, "b");
    }
    elseif (size == 4) {
        add_to_text_buffer(text_buffer, "l");
    }
    elseif (size == 8) {
        add_to_text_buffer(text_buffer, "q");
    }
}

fn emit_instruction_x86(text_buffer: TextBuffer*, instruction: Instruction*) {
    let opcode = instruction->opcode;
    let size = get_size(instruction->type);
    let two_operand_instruction = opcode == MOV || opcode == LOAD || opcode == STORE || opcode == LEA || opcode == SUB || opcode == ADD || opcode == CMP || opcode == IMUL || opcode == AND || opcode == OR || opcode == XOR || opcode == LOADGLOBL || opcode == LEAGLOBL;

    let cmpset_instruction = opcode == CMPSETL || opcode == CMPSETLE || opcode == CMPSETG || opcode == CMPSETGE || opcode == CMPSETE || opcode == CMPSETNE;

    let jmp_instruction = opcode == JMP || opcode == JMPZ;

    if (two_operand_instruction) {
        if (opcode == MOV || opcode == STORE || opcode == LOAD || opcode == LOADGLOBL) {
            add_to_text_buffer(text_buffer, "\tmov");
        }
        elseif (opcode == LEA || opcode == LEAGLOBL) {
            add_to_text_buffer(text_buffer, "\tlea");
        }
        elseif (opcode == SUB) {
            add_to_text_buffer(text_buffer, "\tsub");
        }
        elseif (opcode == ADD) {
            add_to_text_buffer(text_buffer, "\tadd");
        }
        elseif (opcode == CMP) {
            add_to_text_buffer(text_buffer, "\tcmp");
        }
        elseif (opcode == IMUL) {
            add_to_text_buffer(text_buffer, "\timul");
        }
        elseif (opcode == AND) {
            add_to_text_buffer(text_buffer, "\tand");
        }
        elseif (opcode == OR) {
            add_to_text_buffer(text_buffer, "\tor");
        }
        elseif (opcode == XOR) {
            add_to_text_buffer(text_buffer, "\txor");
        }
        else {
            error("Unknown opcode " + int_to_str(opcode as int) + "\n");
        }

        add_size_letter(text_buffer, size);

        add_to_text_buffer(text_buffer, " ");
        emit_operand_x86(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_x86(text_buffer, instruction->dest, size);
        add_to_text_buffer(text_buffer, "\n");
    }
    elseif (cmpset_instruction) {
        add_to_text_buffer(text_buffer, "\tcmp");
        add_size_letter(text_buffer, size);
        add_to_text_buffer(text_buffer, " ");
        emit_operand_x86(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_x86(text_buffer, instruction->dest, size);
        add_to_text_buffer(text_buffer, "\n\tset");
        if (opcode == CMPSETL) {
            add_to_text_buffer(text_buffer, "l");
        }
        elseif (opcode == CMPSETLE) {
            add_to_text_buffer(text_buffer, "le");
        }
        elseif (opcode == CMPSETG) {
            add_to_text_buffer(text_buffer, "g");
        }
        elseif (opcode == CMPSETGE) {
            add_to_text_buffer(text_buffer, "ge");
        }
        elseif (opcode == CMPSETE) {
            add_to_text_buffer(text_buffer, "e");
        }
        elseif (opcode == CMPSETNE) {
            add_to_text_buffer(text_buffer, "ne");
        }
        add_to_text_buffer(text_buffer, " ");
        add_to_text_buffer(text_buffer, "%al"); // TODO: fix this so that there are no hardcoded registers
        add_to_text_buffer(text_buffer, "\n");
    }
    elseif (jmp_instruction) {
        if (opcode == JMP) {
            add_to_text_buffer(text_buffer, "\tjmp");
        }
        elseif (opcode == JMPZ) {
            add_to_text_buffer(text_buffer, "\tjz");
        }
        else {
            error("Unknown opcode " + int_to_str(opcode as int) + "\n");
        }
        add_to_text_buffer(text_buffer, " .");
        emit_operand_x86(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, "\n");
    }
    else {
        if (opcode == NEG) {
            add_to_text_buffer(text_buffer, "\tneg");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == NOT) {
            add_to_text_buffer(text_buffer, "\tnot");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == TESTZ) {
            add_to_text_buffer(text_buffer, "\ttest");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n\tsetz ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == CALL) {
            add_to_text_buffer(text_buffer, "\tcall ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SETE) {
            add_to_text_buffer(text_buffer, "\tsete ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SETNE) {
            add_to_text_buffer(text_buffer, "\tsetne ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == PUSH) {
            add_to_text_buffer(text_buffer, "\tpush");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == POP) {
            add_to_text_buffer(text_buffer, "\tpop");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SAL) {
            // move byte from source to cl
            add_to_text_buffer(text_buffer, "\tmovb ");
            emit_operand_x86(text_buffer, instruction->src, 1);
            add_to_text_buffer(text_buffer, ", %cl\n");
            add_to_text_buffer(text_buffer, "\tsal");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            add_to_text_buffer(text_buffer, "%cl, ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SAR) {
            add_to_text_buffer(text_buffer, "\tmovb ");
            emit_operand_x86(text_buffer, instruction->src, 1);
            add_to_text_buffer(text_buffer, ", %cl\n");
            add_to_text_buffer(text_buffer, "\tsar");
            add_size_letter(text_buffer, size);
            add_to_text_buffer(text_buffer, " ");
            add_to_text_buffer(text_buffer, "%cl, ");
            emit_operand_x86(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == LEAVE) { 
            add_to_text_buffer(text_buffer, "\tleave\n");
            add_to_text_buffer(text_buffer, ".cfi_def_cfa 7, 8\n");
        }
        elseif (opcode == RET) {
            add_to_text_buffer(text_buffer, "\tret\n");
            //add_to_text_buffer(text_buffer, ".cfi_endproc\n");
        }
        elseif (opcode == IDIV) {
            if (size == 4) {
                // TODO: fix this so that there are no hardcoded registers
                add_to_text_buffer(text_buffer, "\tmovl ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %ebx\n");
                add_to_text_buffer(text_buffer, "\tcdq\n");
                add_to_text_buffer(text_buffer, "\tidivl %ebx\n");
            }
            elseif (size == 8) {
                add_to_text_buffer(text_buffer, "\tmovq ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %rbx\n");
                add_to_text_buffer(text_buffer, "\tcqo\n");
                add_to_text_buffer(text_buffer, "\tidivq %rbx\n");
            }
            else {
                error("Unknown size for division" + int_to_str(size) + "\n");
            }
        }
        elseif (opcode == MOD) {
            if (size == 4) {
                add_to_text_buffer(text_buffer, "\tmovl ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %ebx\n");
                add_to_text_buffer(text_buffer, "\tcdq\n");
                add_to_text_buffer(text_buffer, "\tidivl %ebx\n");
                add_to_text_buffer(text_buffer, "\tmovl %edx, ");
                emit_operand_x86(text_buffer, instruction->dest, size);
                add_to_text_buffer(text_buffer, "\n");
            }
            elseif (size == 8) {
                add_to_text_buffer(text_buffer, "\tmovq ");
                emit_operand_x86(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", %rbx\n");
                add_to_text_buffer(text_buffer, "\tcqo\n");
                add_to_text_buffer(text_buffer, "\tidivq %rbx\n");
                add_to_text_buffer(text_buffer, "\tmovq %rdx, ");
                emit_operand_x86(text_buffer, instruction->dest, size);
                add_to_text_buffer(text_buffer, "\n");
            }
            else {
                error("Unknown size for modulo" + int_to_str(size) + "\n");
            }
        }
        elseif (opcode & MOVS == MOVS) { // THIS MUST BE LAST BECAUSE IT USES A BITMASK
            add_to_text_buffer(text_buffer, "\tmovs");
            let src_size = (opcode >> 16) & 15;
            let dst_size = (opcode >> 20) & 15;
            add_size_letter(text_buffer, src_size);
            add_size_letter(text_buffer, dst_size);
            add_to_text_buffer(text_buffer, " ");
            emit_operand_x86(text_buffer, instruction->src, src_size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_x86(text_buffer, instruction->dest, dst_size);
            add_to_text_buffer(text_buffer, "\n");
        }
        else {
            error("Unknown instruction opcode " + int_to_str(opcode) + "\n");
        }
    }
}
fn emit_operand_aarch64(text_buffer: TextBuffer*, operand: Operand*, size: int)

fn print_insides_of_lea(text_buffer: TextBuffer*, operand: Operand*) {
    let offset = (operand->value & (((1 as long) << 32) - 1)) as int;
    let base_register = (operand->value >> 41) & 31;
    let index_register = (operand->value >> 36) & 31;
    let scale = (operand->value >> 32) & 15;
    let mode = (operand->value >> 46) & 3;
    let log_2_scale = 0; // TODO: make this nicer
    if (scale == 2) {
        log_2_scale = 1;
    }
    elseif (scale == 4) {
        log_2_scale = 2;
    }
    elseif (scale == 8) {
        log_2_scale = 3;
    }
    if (mode == REGISTER_INDEXED) {
        emit_operand_aarch64(text_buffer, make_reg(base_register), 8);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_aarch64(text_buffer, make_reg(index_register), 8);
        add_to_text_buffer(text_buffer, ", lsl #" + int_to_str(log_2_scale));
    }
    elseif (mode == REGISTER_RELATIVE) {
        emit_operand_aarch64(text_buffer, make_reg(base_register), 8);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_aarch64(text_buffer, make_imm(offset as long), 8);
        add_to_text_buffer(text_buffer, "\n");
    }
}

fn emit_operand_aarch64(text_buffer: TextBuffer*, operand: Operand*, size: int) {
    if (operand->type == REG) {
        if (operand->value == 31) {
            if (size == 4 || size == 1) {
                add_to_text_buffer(text_buffer, "wzr");
            }
            elseif (size == 8) {
                add_to_text_buffer(text_buffer, "xzr");
            }
            else {
                error("Unknown regiser, has no name and no size\n");
            }
            return;
        }
        if (size == 4 || size == 1) {
            add_to_text_buffer(text_buffer, register_names_dword[operand->value & 31]);
        }
        elseif (size == 8) {
            add_to_text_buffer(text_buffer, register_names_qword[operand->value & 31]);
        }
        else {
            error("Unknown size for operand " + int_to_str(size) + "\n");
        }
    } elseif (operand->type == MEM) {
        // TODO: this is duplicated code, bad, very bad
        let mode = (operand->value >> 46) & 3;

        if (mode == REGISTER_RELATIVE) {
            add_to_text_buffer(text_buffer, "[");
            let base_register = (operand->value >> 41) & 31;
            let offset = (operand->value & (((1 as long) << 32) - 1)) as int;
            emit_operand_aarch64(text_buffer, make_reg(base_register), 8);
            if (offset != 0) {
                add_to_text_buffer(text_buffer, ", #" + int_to_str(offset));
            }
            add_to_text_buffer(text_buffer, "]");
        }
        elseif (mode == REGISTER_INDEXED) {
            add_to_text_buffer(text_buffer, "[");
            print_insides_of_lea(text_buffer, operand);
            add_to_text_buffer(text_buffer, "]");
        }
    } elseif (operand->type == IMM) {
        if (operand->value > ((1 as long) << 16)) {
            error("Immediate value is too large for aarch64: " + long_to_str(operand->value) + "\n");
        }
        add_to_text_buffer(text_buffer, "#" + long_to_str(operand->value));
    } elseif (operand->type == LABEL) {
        add_to_text_buffer(text_buffer, operand->value as str);
    } elseif (operand->type == STDLIB_LABEL) {
        add_to_text_buffer(text_buffer, "_" + operand->value as str);
    } elseif (operand->type == RELATIVE_LABEL) {
        add_to_text_buffer(text_buffer, "_" + operand->value as str);
    } else {
        error("Unknown operand type " + int_to_str(operand->type) + "\n");
    }
}

fn emit_instruction_aarch64(text_buffer: TextBuffer*, instruction: Instruction*) {
    let opcode = instruction->opcode;
    let size = get_size(instruction->type);
    // this is duplicated code, bad, very bad, TODO: fix this

    let three_operand_instruction = opcode == ADD || opcode == SUB || opcode == IMUL || opcode == AND || opcode == OR || opcode == XOR || opcode == SAL || opcode == SAR;

    let cmpset_instruction = opcode == CMPSETL || opcode == CMPSETLE || opcode == CMPSETG || opcode == CMPSETGE || opcode == CMPSETE || opcode == CMPSETNE;

    let jmp_instruction = opcode == JMP || opcode == JMPZ;

    if (cmpset_instruction || opcode == CMP) {
        if (instruction->dest->type == IMM) {
            let t = instruction->dest->type;
            instruction->dest->type = instruction->src->type;
            instruction->src->type = t;
        }
        if (instruction->src->type == IMM) {
            if (instruction->src->value == 0) {
                instruction->src = make_reg(31 as long);
            }
            else {
                error("Only 0 can be used as immediate value for cmp\n");
            }
        }
    }

    if (three_operand_instruction) {
        if (opcode == ADD) {
            if (instruction->dest->type == MEM) {
                add_to_text_buffer(text_buffer, "\tldr x12, ");
                emit_operand_aarch64(text_buffer, instruction->dest, size);
                add_to_text_buffer(text_buffer, "\n");

                add_to_text_buffer(text_buffer, "\tadd x12, x12, ");
                emit_operand_aarch64(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, "\n");

                add_to_text_buffer(text_buffer, "\tstr x12, ");
                emit_operand_aarch64(text_buffer, instruction->dest, size);
                add_to_text_buffer(text_buffer, "\n");
                return;
            }
            add_to_text_buffer(text_buffer, "\tadd");
        }
        elseif (opcode == SUB) {
            add_to_text_buffer(text_buffer, "\tsub");
        }
        elseif (opcode == IMUL) {
            add_to_text_buffer(text_buffer, "\tmul");
        }
        elseif (opcode == AND) {
            add_to_text_buffer(text_buffer, "\tand");
        }
        elseif (opcode == OR) {
            add_to_text_buffer(text_buffer, "\torr");
        }
        elseif (opcode == XOR) {
            add_to_text_buffer(text_buffer, "\teor");
        }
        elseif (opcode == SAL) {
            add_to_text_buffer(text_buffer, "\tlsl");
        }
        elseif (opcode == SAR) {
            add_to_text_buffer(text_buffer, "\tasr");
        }
        else {
            error("Unknown opcode " + int_to_str(opcode as int) + "\n");
        }

        add_to_text_buffer(text_buffer, " ");
        emit_operand_aarch64(text_buffer, instruction->dest, size);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_aarch64(text_buffer, instruction->dest, size);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_aarch64(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, "\n");
    }
    elseif (cmpset_instruction) {
        add_to_text_buffer(text_buffer, "\tcmp");
        add_to_text_buffer(text_buffer, " ");
        emit_operand_aarch64(text_buffer, instruction->dest, size);
        add_to_text_buffer(text_buffer, ", ");
        emit_operand_aarch64(text_buffer, instruction->src, size);

        add_to_text_buffer(text_buffer, "\n\tcset w0, "); // TODO: fix this so that there are no hardcoded registers
        if (opcode == CMPSETL) {
            add_to_text_buffer(text_buffer, "lt");
        }
        elseif (opcode == CMPSETLE) {
            add_to_text_buffer(text_buffer, "le");
        }
        elseif (opcode == CMPSETG) {
            add_to_text_buffer(text_buffer, "gt");
        }
        elseif (opcode == CMPSETGE) {
            add_to_text_buffer(text_buffer, "ge");
        }
        elseif (opcode == CMPSETE) {
            add_to_text_buffer(text_buffer, "eq");
        }
        elseif (opcode == CMPSETNE) {
            add_to_text_buffer(text_buffer, "ne");
        }
        add_to_text_buffer(text_buffer, "\n");
    }
    elseif (jmp_instruction) {
        if (opcode == JMP) {
            add_to_text_buffer(text_buffer, "\tb");
        } elseif (opcode == JMPZ) {
            add_to_text_buffer(text_buffer, "\tbeq");
        } else {
            error("Unknown opcode " + int_to_str(opcode as int) + "\n");
        }

        add_to_text_buffer(text_buffer, " .");
        emit_operand_aarch64(text_buffer, instruction->src, size);
        add_to_text_buffer(text_buffer, "\n");
    }
    else {
        if (opcode == LOAD) {
            add_to_text_buffer(text_buffer, "\tldr");
            if (size == 1) {
                add_to_text_buffer(text_buffer, "b");
            }
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == STORE) {
            if (instruction->src->type == IMM) {
                if (size == 1 || size == 4) {
                    add_to_text_buffer(text_buffer, "\tmov w9, ");
                    emit_operand_aarch64(text_buffer, instruction->src, size);
                    add_to_text_buffer(text_buffer, "\n");

                    add_to_text_buffer(text_buffer, "\tstr w9, ");
                }
                else {
                    add_to_text_buffer(text_buffer, "\tmov x9, ");
                    emit_operand_aarch64(text_buffer, instruction->src, size);
                    add_to_text_buffer(text_buffer, "\n");

                    add_to_text_buffer(text_buffer, "\tstr x9, ");
                }
            }
            else {
                add_to_text_buffer(text_buffer, "\tstr");
                if (size == 1) {
                    add_to_text_buffer(text_buffer, "b");
                }
                add_to_text_buffer(text_buffer, " ");
                emit_operand_aarch64(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, ", ");
            }
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == MOV) {
            add_to_text_buffer(text_buffer, "\tmov");
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == LEA) {
            if (instruction->src->type != MEM) {
                error("LEA instruction must have a memory source\n");
            }
            if (instruction->dest->type != REG) {
                error("LEA instruction must have a register destination\n");
            }

            add_to_text_buffer(text_buffer, "\tadd ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            print_insides_of_lea(text_buffer, instruction->src);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == LOADGLOBL) {
            add_to_text_buffer(text_buffer, "\tadrp ");
            emit_operand_aarch64(text_buffer, instruction->dest, 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "@PAGE\n");

            add_to_text_buffer(text_buffer, "\tadd ");
            emit_operand_aarch64(text_buffer, instruction->dest, 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "@PAGEOFF\n");

            add_to_text_buffer(text_buffer, "\tldr");
            if (size == 1) {
                add_to_text_buffer(text_buffer, "b");
            }
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", [");
            emit_operand_aarch64(text_buffer, instruction->dest, 8);
            add_to_text_buffer(text_buffer, "]\n");
        }
        elseif (opcode == LEAGLOBL) {
            
            add_to_text_buffer(text_buffer, "\tadrp ");
            emit_operand_aarch64(text_buffer, instruction->dest, 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "@PAGE\n");

            add_to_text_buffer(text_buffer, "\tadd ");
            emit_operand_aarch64(text_buffer, instruction->dest, 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, 8);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "@PAGEOFF\n");

        }
        elseif (opcode == NEG) {
            add_to_text_buffer(text_buffer, "\tneg");
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == NOT) {
            add_to_text_buffer(text_buffer, "\tmvn");
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == CMP) {
            add_to_text_buffer(text_buffer, "\tcmp");
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == TESTZ) {
            add_to_text_buffer(text_buffer, "\ttst");
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->src, size); add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n\tcset ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", eq");
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == CALL) {
            add_to_text_buffer(text_buffer, "\tbl ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SETE) { // TODO; is this needed?
            add_to_text_buffer(text_buffer, "cset ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", eq\n");
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == SETNE) {
            add_to_text_buffer(text_buffer, "cset ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ne\n");
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == PUSH) {
            add_to_text_buffer(text_buffer, "\tsub sp, sp, #" + int_to_str(size) + "\n");
            add_to_text_buffer(text_buffer, "\tstr");
            if (size == 1) {
                add_to_text_buffer(text_buffer, "b");
            }
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, ", [sp]\n");
        }
        elseif (opcode == POP) {
            add_to_text_buffer(text_buffer, "\tldr");
            if (size == 1) {
                add_to_text_buffer(text_buffer, "b");
            }
            add_to_text_buffer(text_buffer, " ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", [sp]\n");
            add_to_text_buffer(text_buffer, "\tadd sp, sp, #" + int_to_str(size) + "\n");
        }
        elseif (opcode == LEAVE) {
            add_to_text_buffer(text_buffer, "\tmov sp, x29\n");
            add_to_text_buffer(text_buffer, "\tldp x29, x30, [sp], #16\n");
        }
        elseif (opcode == RET) {
            add_to_text_buffer(text_buffer, "\tret\n");
        }
        elseif (opcode == IDIV) {
            add_to_text_buffer(text_buffer, "\tsdiv ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode == MOD) {
            add_to_text_buffer(text_buffer, "\tsdiv ");
            emit_operand_aarch64(text_buffer, make_reg(RDX), size); // X3
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, "\n");
                    
            add_to_text_buffer(text_buffer, "\tmsub ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, make_reg(RDX), size); // X3
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->src, size);
            add_to_text_buffer(text_buffer, ", ");
            emit_operand_aarch64(text_buffer, instruction->dest, size);
            add_to_text_buffer(text_buffer, "\n");
        }
        elseif (opcode & MOVS == MOVS) {
            let src_size = (opcode >> 16) & 15;
            let dst_size = (opcode >> 20) & 15;
            if (src_size == 4 && dst_size == 8) {
                add_to_text_buffer(text_buffer, "\tsxtw");
                add_to_text_buffer(text_buffer, " ");
                emit_operand_aarch64(text_buffer, instruction->dest, dst_size);
                add_to_text_buffer(text_buffer, ", ");
                emit_operand_aarch64(text_buffer, instruction->src, src_size);
                add_to_text_buffer(text_buffer, "\n");
            }
            else {
                size = dst_size;
                add_to_text_buffer(text_buffer, "\tmov");
                add_to_text_buffer(text_buffer, " ");
                emit_operand_aarch64(text_buffer, instruction->dest, size);
                add_to_text_buffer(text_buffer, ", ");
                emit_operand_aarch64(text_buffer, instruction->src, size);
                add_to_text_buffer(text_buffer, "\n");
            }
            
        }
    }
}

fn emit_instruction(text_buffer: TextBuffer*, instruction: Instruction*) {
    if (current_target == X86_64) {
        emit_instruction_x86(text_buffer, instruction);
    }
    elseif (current_target == AARCH64) {
        emit_instruction_aarch64(text_buffer, instruction);
    }
    else {
        error("Unknown target " + int_to_str(current_target) + "\n");
    }
}

fn encode_sizes_in_opcode(opcode: int, src_type: int, dst_type: int): int {
    let src_size = get_size(src_type);
    let dst_size = get_size(dst_type);
    opcode = opcode | (src_size << 16);
    opcode = opcode | (dst_size << 20);
    return opcode;
}

let rsp_offset = 0;

fn align_stack(text_buffer: TextBuffer*, offset: int): int {
    if (current_target == X86_64) {
        let alignment_offset = (offset % 16 + 16) % 16;

        if (alignment_offset != 0) {
            //add_to_text_buffer(text_buffer, "\tsubq $" + int_to_str(alignment_offset) + ", %rsp\n");
            add_instruction(text_buffer, make_imm(alignment_offset as long), make_reg(RSP), SUB, LONG_VARIABLE);
            rsp_offset = rsp_offset - alignment_offset;
        }
        return alignment_offset;
    }
    else {
        return 0;
    }
}

fn dealign_stack(text_buffer: TextBuffer*, offset: int) {
    if (current_target == X86_64) {
        if (offset != 0) {
            //add_to_text_buffer(text_buffer, "\taddq $" + int_to_str(offset) + ", %rsp\n");
            add_instruction(text_buffer, make_imm(offset as long), make_reg(RSP), ADD, LONG_VARIABLE);
            rsp_offset = rsp_offset + offset;
        }
    }
}

fn allocate_stack_space(text_buffer: TextBuffer*, stack_frame: StackFrame*) {
    let stack_frame_size = -(stack_frame->stack_size);
    if (stack_frame_size > 0) {
        stack_frame_size = (stack_frame_size + 15) & (!15);
        //add_to_text_buffer(text_buffer, "\tsubq $" + int_to_str(stack_frame_size) + ", %rsp\n");
        add_instruction(text_buffer, make_imm(stack_frame_size as long), make_reg(RSP), SUB, LONG_VARIABLE);
    }
}

fn deallocate_stack_space(text_buffer: TextBuffer*, stack_frame: StackFrame*) {
    let stack_frame_size = -(stack_frame->stack_size);
    if (stack_frame_size > 0) {
        stack_frame_size = (stack_frame_size + 15) & (!15);
        //add_to_text_buffer(text_buffer, "\tsubq $" + int_to_str(stack_frame_size) + ", %rsp\n");
        add_instruction(text_buffer, make_imm(stack_frame_size as long), make_reg(RSP), ADD, LONG_VARIABLE);
    }
}

fn push_register(text_buffer: TextBuffer*, operand: Operand*, operand_type: int, offset: int, size: int) {
    if (current_target == X86_64) {
        let operand_size = get_size(operand_type);
        if (operand_size == 8) {
            add_instruction(text_buffer, operand, 0 as Operand*, PUSH, operand_type);
        }
        else {
            add_instruction(text_buffer, make_imm(operand_size as long), make_reg(RSP), SUB, LONG_VARIABLE);
            add_instruction(text_buffer, operand, make_mem(make_reg(RSP), 0 as Operand*, 0, 0, REGISTER_RELATIVE), STORE, operand_type);
        }
        rsp_offset = rsp_offset - get_size(operand_type);
    }
    elseif (current_target == AARCH64) {
        add_instruction(text_buffer,  operand, make_mem(make_reg(RSP), 0 as Operand*, 0, offset, REGISTER_RELATIVE), STORE, operand_type);
    }
}

fn pop_register(text_buffer: TextBuffer*, operand: Operand*, operand_type: int, offset: int, size: int) {
    if (current_target == X86_64) {
        let operand_size = get_size(operand_type);
        if (operand_size == 8) {
            add_instruction(text_buffer, operand, 0 as Operand*, POP, operand_type);
        }
        else {
            add_instruction(text_buffer, make_mem(make_reg(RSP), 0 as Operand*, 0, 0, REGISTER_RELATIVE), operand, LOAD, operand_type);
            add_instruction(text_buffer, make_imm(operand_size as long), make_reg(RSP), ADD, LONG_VARIABLE);
        }
        rsp_offset = rsp_offset + get_size(operand_type);
    }
    elseif (current_target == AARCH64) {
        add_instruction(text_buffer, make_mem(make_reg(RSP), 0 as Operand*, 0, offset, REGISTER_RELATIVE), operand, LOAD, operand_type);
    }
}

fn reserve_stack_space(text_buffer: TextBuffer*, size: int) {
    if (current_target == AARCH64) {
        add_instruction(text_buffer, make_imm(size as long), make_reg(RSP), SUB, LONG_VARIABLE);
    }
}

fn free_stack_space(text_buffer: TextBuffer*, size: int) {
    if (current_target == AARCH64) {
        add_instruction(text_buffer, make_imm(size as long), make_reg(RSP), ADD, LONG_VARIABLE);
    }
}

let label_index = 0;

fn get_label_index(): int {
    label_index = label_index + 1;
    return label_index;
}


fn compile_expression_into_register(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, reg: long, type: int): int

fn compile_unary_expression(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, type: int): int {
    let unary_expression_node = (node->node as UnaryExpressionNode*);
    let lrtype = RVALUE;
    if (unary_expression_node->unary_expression_type == AT) {
        lrtype = LVALUE;
    }
    let value_type = compile_expression_into_register(text_buffer, unary_expression_node->value, stack_frame, RAX, lrtype);

    if (unary_expression_node->unary_expression_type == ASTERISK && type == RVALUE) {
        if (is_pointer(value_type) || is_array(value_type)) {
            value_type = dereference_type(value_type);
        }
        else {
            print_location_of_error(node->loc);
            error("Unary * must have a pointer or an array as a type\n");
        }
    }


    if (unary_expression_node->unary_expression_type == MINUS) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("Unary minus is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tneg " + register_name + "\n");
        add_instruction(text_buffer, 0 as Operand*, make_reg(RAX), NEG, value_type);
    }
    elseif (unary_expression_node->unary_expression_type == PLUS) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("Unary plus is not allowed as lvalue\n");
        }
    }
    elseif (unary_expression_node->unary_expression_type == ASTERISK) {
        if (type == RVALUE) {
            //add_to_text_buffer(text_buffer, "\tmov" + word_size + " (" + pointer_register_name + "), " + register_name + "\n");

            add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(RAX), LOAD, value_type);
        }
        elseif (type == LVALUE) {
            //add_to_text_buffer(text_buffer, "\tleaq" + " (" + pointer_register_name + "), " + register_name + "\n");

            add_instruction(text_buffer, make_reg(RAX), make_reg(RAX),  MOV, LONG_VARIABLE); // this does nothing, this lea can be a mov
        }
    }
    elseif (unary_expression_node->unary_expression_type == BANG) {
        //TODO: add tilde and fix this
        if (value_type == BOOL_VARIABLE) {
            //add_to_text_buffer(text_buffer, "\ttestb " + register_name + ", " + register_name + "\n\tsetz %al\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(RAX), TESTZ, BOOL_VARIABLE);
        }
        else {
            //add_to_text_buffer(text_buffer, "\tnot " + register_name + "\n");
            add_instruction(text_buffer, 0 as Operand*, make_reg(RAX), NOT, value_type);
        }
    }
    else {
        print_location_of_error(node->loc);
        error("Unknown unary expression type " + debug_token_value_to_str(unary_expression_node->unary_expression_type) + "\n");
    }
    return value_type;
}

fn compile_char_into_builder(text_buffer: TextBuffer*) {
    let index = get_label_index();

    let alignment_offset = align_stack(text_buffer, rsp_offset);
    add_instruction(text_buffer, make_label("__append_char_to_builder"), 0 as Operand*, CALL, VOID);
    //add_to_text_buffer(text_buffer, "\tcall __append_char_to_builder\n");
    dealign_stack(text_buffer, alignment_offset);
}

fn compile_string_into_builder(text_buffer: TextBuffer*) {
    let ___index = get_label_index();
    
    let alignment_offset = align_stack(text_buffer, rsp_offset);
    //add_to_text_buffer(text_buffer, "\tcall __append_string_to_builder\n");
    add_instruction(text_buffer, make_label("__append_string_to_builder"), 0 as Operand*, CALL, VOID);
    dealign_stack(text_buffer, alignment_offset);
}

fn compile_binary_expression(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*): int {
    let binary_expression_node = (node->node as BinaryExpressionNode*);
    let operator = binary_expression_node->binary_expression_type;
    let right_expression_type = binary_expression_node->right->type;

    let preserve_rax = right_expression_type == EXPRESSION_BINARY || right_expression_type == EXPRESSION_FUNCTION_CALL || right_expression_type == EXPRESSION_ARROW || right_expression_type == EXPRESSION_UNARY || right_expression_type == EXPRESSION_INDEX || right_expression_type == EXPRESSION_AS || right_expression_type == EXPRESSION_DOUBLE_COLON;

    let left_type = compile_expression_into_register(text_buffer, binary_expression_node->left, stack_frame, RAX, RVALUE);


    if (preserve_rax) {
        reserve_stack_space(text_buffer, 16);
        push_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);
    }

    let right_type = compile_expression_into_register(text_buffer, binary_expression_node->right, stack_frame, RDX, RVALUE);

    if (preserve_rax) {
        pop_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);
        free_stack_space(text_buffer, 16);
    }


    let right_underlying_type = get_underlying_type(right_type);
    let is_right_char = (right_underlying_type == to_pointer(CHAR_VARIABLE)) || (right_underlying_type == CHAR_VARIABLE);

    let left_underlying_type = get_underlying_type(left_type);
    let is_left_char = (left_underlying_type == to_pointer(CHAR_VARIABLE)) || (left_underlying_type == CHAR_VARIABLE);

    if (operator == PLUS && left_type == STRING_BUILDER_VARIABLE && is_right_char && right_expression_type != EXPRESSION_FUNCTION_CALL) {
        //add_to_text_buffer(text_buffer, "\tmovq %rdx, %r12\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(R12), MOV, LONG_VARIABLE);
        if (right_type == CHAR_VARIABLE) {
            compile_char_into_builder(text_buffer);
        }
        else {
            compile_string_into_builder(text_buffer);
        }

        //add_to_text_buffer(text_buffer, "\tmovq %r15, %rax\n");
        add_instruction(text_buffer, make_reg(R15), make_reg(RAX), MOV, LONG_VARIABLE);
        return STRING_BUILDER_VARIABLE;
    }
    elseif (operator == PLUS && is_left_char && is_right_char) {
        reserve_stack_space(text_buffer, 16);
        push_register(text_buffer, make_reg(RDX), LONG_VARIABLE, 0, 16);
        push_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 8, 16);

        //add_to_text_buffer(text_buffer, "\tmovq $64, %rdi\n");
        add_instruction(text_buffer, make_imm(64 as long), make_reg(RDI), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tcall malloc\n");
        add_instruction(text_buffer, make_stdlib_label("malloc"), 0 as Operand*, CALL, VOID);
        //add_to_text_buffer(text_buffer, "\tmovq %rax, %r15\n");
        add_instruction(text_buffer, make_reg(RAX), make_reg(R15), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tmovq $0, %r14\n");
        add_instruction(text_buffer, make_imm(0 as long), make_reg(R14), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tmovq $64, %r13\n");
        add_instruction(text_buffer, make_imm(64 as long), make_reg(R13), MOV, LONG_VARIABLE);

        pop_register(text_buffer, make_reg(R12), LONG_VARIABLE, 8, 16);
        if (left_type == CHAR_VARIABLE) {
            compile_char_into_builder(text_buffer);
        }
        else {
            compile_string_into_builder(text_buffer);
        }

        pop_register(text_buffer, make_reg(R12), LONG_VARIABLE, 0, 16);
        if (right_type == CHAR_VARIABLE) {
            compile_char_into_builder(text_buffer);
        }
        else {
            compile_string_into_builder(text_buffer);
        }

        //add_to_text_buffer(text_buffer, "\tmovq %r15, %rax\n");
        add_instruction(text_buffer, make_reg(R15), make_reg(RAX), MOV, LONG_VARIABLE);
        free_stack_space(text_buffer, 16);
        return STRING_BUILDER_VARIABLE;
    }

    
    if ((get_underlying_type(left_type) == to_pointer(CHAR_VARIABLE)) &&
        (get_underlying_type(right_type) == to_pointer(CHAR_VARIABLE))) {
        if (!(operator == EQ || operator == NEQ)) {
            print_location_of_error(node->loc);
            error("Unknown operator to compare 2 strings " + debug_token_value_to_str(operator) + "\n");
        } 
        //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
        add_instruction(text_buffer, make_reg(RAX), make_reg(RDI), MOV, LONG_VARIABLE);
        //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rsi\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RSI), MOV, LONG_VARIABLE);

        let alignment_offset = align_stack(text_buffer, rsp_offset);
        //add_to_text_buffer(text_buffer, "\tcall strcmp\n");
        add_instruction(text_buffer, make_stdlib_label("strcmp"), 0 as Operand*, CALL, VOID);
        //add_to_text_buffer(text_buffer, "\tcmpq $0, %rax\n");

        add_instruction(text_buffer, make_imm(0 as long), make_reg(RAX), CMP, LONG_VARIABLE); // TODO: move this into CMPSETE
        if (operator == EQ) {
            //add_to_text_buffer(text_buffer, "\tsete %al\n");
            add_instruction(text_buffer, 0 as Operand*, make_reg(RAX), SETE, BOOL_VARIABLE);
        }
        elseif (operator == NEQ) {
            //add_to_text_buffer(text_buffer, "\tsetne %al\n");
            add_instruction(text_buffer, 0 as Operand*, make_reg(RAX), SETNE, BOOL_VARIABLE);
        }
        else {
            print_location_of_error(node->loc);
            error("Unknown operator to compare 2 strings " + debug_token_value_to_str(operator) + "\n");
        }

        dealign_stack(text_buffer, alignment_offset);
        return BOOL_VARIABLE;
    }

    left_type = get_underlying_type(left_type);
    right_type = get_underlying_type(right_type);

    if (left_type != right_type) {
        if ((left_type == CHAR_VARIABLE || left_type == INT_VARIABLE || left_type == LONG_VARIABLE) && (right_type == CHAR_VARIABLE || right_type == INT_VARIABLE || right_type == LONG_VARIABLE)) {
            let left_size = get_size(left_type);
            let right_size = get_size(right_type);

            if (left_size < right_size) {
                //add_to_text_buffer(text_buffer, "\tmovs" + get_word_size(left_size) + get_word_size(right_size) + " " + source_register + ", " + destination_register + "\n");
                add_instruction(text_buffer, make_reg(RAX), make_reg(RAX), encode_sizes_in_opcode(MOVS, left_type, right_type), VOID);
                left_type = right_type;

            }
            elseif (right_size < left_size) {
                //add_to_text_buffer(text_buffer, "\tmovs" + get_word_size(right_size) + get_word_size(left_size) + " " + source_register + ", " + destination_register + "\n");
                add_instruction(text_buffer, make_reg(RDX), make_reg(RDX), encode_sizes_in_opcode(MOVS, right_type, left_type), VOID);
                right_type = left_type;
            }
        }
        elseif ((is_pointer(left_type) || left_type == PTR_VARIABLE) && (is_pointer(right_type) || right_type == PTR_VARIABLE)) {
            left_type = PTR_VARIABLE;
            right_type = PTR_VARIABLE;
        }
        else {
            print_location_of_error(node->loc);
            error("Implicit conversion of non numeric types not implemented, types are: " + debug_variable_type_name(left_type) + " and " + debug_variable_type_name(right_type) + "\n");
        }
    }
  
    let type = left_type;


    if (operator == PLUS) {
        //add_to_text_buffer(text_buffer, "\tadd" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), ADD, type);
    }
    elseif (operator == MINUS) {
        //add_to_text_buffer(text_buffer, "\tsub" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), SUB, type);
    }
    elseif (operator == ASTERISK) {
        //add_to_text_buffer(text_buffer, "\timul" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), IMUL, type);
    }
    elseif (operator == SLASH) {
        if (type != INT_VARIABLE && type != LONG_VARIABLE) {
            print_location_of_error(node->loc);
            error("Division not implemented for non-int types\n");
        }
        if (get_size(type) == 4) {
            //add_to_text_buffer(text_buffer, "\tmovl %edx, %ebx\n"); //add_to_text_buffer(text_buffer, "\tcdq\n"); //add_to_text_buffer(text_buffer, "\tidivl %ebx\n");
        }
        elseif (get_size(type) == 8) {
            //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rbx\n"); //add_to_text_buffer(text_buffer, "\tcqo\n"); //add_to_text_buffer(text_buffer, "\tidivq %rbx\n");
        }
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), IDIV, type);
    }
    elseif (operator == MODULO) {
        if (type != INT_VARIABLE && type != LONG_VARIABLE) {
            print_location_of_error(node->loc);
            error("Modulo not implemented for non-int types\n");
        }
        if (get_size(type) == 4) {
            //add_to_text_buffer(text_buffer, "\tmovl %edx, %ebx\n"); //add_to_text_buffer(text_buffer, "\tcdq\n"); //add_to_text_buffer(text_buffer, "\tidivl %ebx\n"); //add_to_text_buffer(text_buffer, "\tmovl %edx, %eax\n");
        }
        elseif (get_size(type) == 8) {
            //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rbx\n"); //add_to_text_buffer(text_buffer, "\tcqo\n"); //add_to_text_buffer(text_buffer, "\tidivq %rbx\n"); //add_to_text_buffer(text_buffer, "\tmovq %rdx, %rax\n");
        }
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), MOD, type);
    }
    elseif (operator == LT) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetl %al\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), CMPSETL, type);
    }
    elseif (operator == LTE) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetle %al\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), CMPSETLE, type);
    }
    elseif (operator == GT) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetg %al\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), CMPSETG, type);
    }
    elseif (operator == GTE) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetge %al\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), CMPSETGE, type);
    }
    elseif (operator == EQ) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsete %al\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), CMPSETE, type);
    }
    elseif (operator == NEQ) {
        //add_to_text_buffer(text_buffer, "\tcmp" + word_size + " " + right_register + ", " + left_register + "\n\tsetne %al\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), CMPSETNE, type);
    }
    elseif (operator == LOGICAL_AND || operator == BITWISE_AND) {
        //add_to_text_buffer(text_buffer, "\tand" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), AND, type);
    }
    elseif (operator == LOGICAL_OR || operator == BITWISE_OR) {
        //add_to_text_buffer(text_buffer, "\tor" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), OR, type);
    }
    elseif (operator == LOGICAL_XOR || operator == BITWISE_XOR) {
        //add_to_text_buffer(text_buffer, "\txor" + word_size + " " + right_register + ", " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), XOR, type);
    }
    elseif (operator == BITWISE_LEFT_SHIFT) {
        //add_to_text_buffer(text_buffer, "\tmovb %dl, %cl\n"); //add_to_text_buffer(text_buffer, "\tsal" + word_size + " %cl, " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), SAL, type);
    }
    elseif (operator == BITWISE_RIGHT_SHIFT) {
        //add_to_text_buffer(text_buffer, "\tmovb %dl, %cl\n"); //add_to_text_buffer(text_buffer, "\tsar" + word_size + " %cl, " + left_register + "\n");
        add_instruction(text_buffer, make_reg(RDX), make_reg(RAX), SAR, type);
    }
    else {
        print_location_of_error(node->loc);
        error("Unknown binary expression type " + int_to_str(operator) + "\n");
    }

    if (operator == PLUS || operator == MINUS || operator == ASTERISK || operator == SLASH || operator == MODULO || operator == BITWISE_AND || operator == BITWISE_OR || operator == BITWISE_XOR || operator == BITWISE_LEFT_SHIFT || operator == BITWISE_RIGHT_SHIFT) {
        return type;
    }
    elseif (operator == LT || operator == LTE || operator == GT || operator == GTE || operator == EQ || operator == NEQ || operator == LOGICAL_AND || operator == LOGICAL_OR || operator == LOGICAL_XOR) {
        return BOOL_VARIABLE;
    }
    else {
        print_location_of_error(node->loc);
        error("Unknown binary expression type " + int_to_str(operator) + "\n");
    }
}

fn compile_function_call(node: AstNode*, text_buffer: TextBuffer*, stack_frame: StackFrame*, reg: long, type: int): int {
    let function_call_node = (node->node as FunctionCallNode*);
    let name = function_call_node->name;


    if (name == "len") {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("len function is not allowed as lvalue\n");
        }
        if (function_call_node->arguments.len() != 1) {
            print_location_of_error(node->loc);
            error("len function takes exactly one argument\n");
        }
        let argument = function_call_node->arguments[0];
        let argument_type = compile_expression_into_register(text_buffer, argument, stack_frame, RAX, RVALUE);
        if (argument_type == STRING_VARIABLE || argument_type == STRING_LITERAL_VARIABLE || argument_type == STRING_BUILDER_VARIABLE) {
            let alignment_offset = align_stack(text_buffer, rsp_offset);
            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(RDI), MOV, LONG_VARIABLE);

            //add_to_text_buffer(text_buffer, "\tcall strlen\n");
            add_instruction(text_buffer, make_stdlib_label("strlen"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovl %eax, " + get_register_for_type(reg, INT_VARIABLE) + "\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(reg), MOV, INT_VARIABLE);
            dealign_stack(text_buffer, alignment_offset);
            return INT_VARIABLE;
        }
        elseif (is_array(argument_type)) {
            //add_to_text_buffer(text_buffer, "\tmovl 8(%rax), " + get_register_for_type(reg, INT_VARIABLE) + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, 8, REGISTER_RELATIVE), make_reg(reg), LOAD, INT_VARIABLE);
            return INT_VARIABLE;
        }
        else {
            print_location_of_error(node->loc);
            error("Len function can only be used on strings and arrays\n");
        }
    }
    elseif (name == "capacity") {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("capacity function is not allowed as lvalue\n");
        }
        if (function_call_node->arguments.len() != 1) {
            print_location_of_error(node->loc);
            error("capacity function takes exactly one argument\n");
        }
        let argument = function_call_node->arguments[0];
        let argument_type = compile_expression_into_register(text_buffer, argument, stack_frame, RAX, RVALUE);
        if (is_array(argument_type)) {
            //add_to_text_buffer(text_buffer, "\tmovl " + int_to_str(12) + "(%rax), " + get_register_for_type(reg, INT_VARIABLE) + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, 12, REGISTER_RELATIVE), make_reg(reg), LOAD, INT_VARIABLE);

            return INT_VARIABLE;
        }
        else {
            print_location_of_error(node->loc);
            error("Capacity function can only be used on arrays\n");
        }
    }
    elseif (name == "append") {
        if (function_call_node->arguments.len() != 2) {
            print_location_of_error(node->loc);
            error("append function takes exactly two arguments, got " + int_to_str(function_call_node->arguments.len()) + "\n");
        }
        let alignment_offset = align_stack(text_buffer, rsp_offset);

        let array_type = compile_expression_into_register(text_buffer, function_call_node->arguments[0], stack_frame, RAX, RVALUE);

        reserve_stack_space(text_buffer, 16);
        push_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);

        let element_type = compile_expression_into_register(text_buffer, function_call_node->arguments[1], stack_frame, RBX, RVALUE);

        pop_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);
        free_stack_space(text_buffer, 16);

        let ___index = get_label_index(); // TODO: remove this later, this is here so that the label numbers are the same as before

        let size = get_size(element_type);
        if (size == 1) {
            //add_to_text_buffer(text_buffer, "\tcall __append_char\n");
            add_instruction(text_buffer, make_label("__append_char"), 0 as Operand*, CALL, VOID);
        }
        elseif (size == 4) {
            //add_to_text_buffer(text_buffer, "\tcall __append_long\n");
            add_instruction(text_buffer, make_label("__append_long"), 0 as Operand*, CALL, VOID);
        }
        elseif (size == 8) {
            //add_to_text_buffer(text_buffer, "\tcall __append_quad\n");
            add_instruction(text_buffer, make_label("__append_quad"), 0 as Operand*, CALL, VOID);
        }

        
        if (type == LVALUE) {
            element_type = to_pointer(element_type);
        }

        if (type == RVALUE) {
            //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(element_type)) + " (%rax), " + get_register_for_type(reg, element_type) + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(reg), LOAD, element_type);
        }
        elseif (type == LVALUE) {
            //add_to_text_buffer(text_buffer, "\tlea" + get_word_size(get_size(element_type)) + " (%rax), " + get_register_for_type(reg, element_type) + "\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(reg), MOV, LONG_VARIABLE);
            // Im not sure this ^^^ is correct
        }


        //add_to_text_buffer(text_buffer, "\taddl $1, 8(%r12)\n");
        add_instruction(text_buffer, make_imm(1 as long), make_mem(make_reg(R12), 0 as Operand*, 0, 8, REGISTER_RELATIVE), ADD, INT_VARIABLE);
        dealign_stack(text_buffer, alignment_offset);
        return element_type;
    }
    else {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("User defined function call is not allowed as lvalue\n");
        }


        let function_signature = get_signature(function_registry, name);

        if (function_signature->parameters.len() != function_call_node->arguments.len()) {
            print_location_of_error(node->loc);
            error("Mismatch in number of arguments when calling function " + name + ". Expected " + int_to_str(function_signature->parameters.len()) + ", got " + int_to_str(function_call_node->arguments.len()) + "\n");
        }

        let arguments_size = 0;
        for (let i = 0; i < function_signature->parameters.len(); i = i + 1) {
            arguments_size = arguments_size + get_size(function_signature->parameters[i]->type);
        }

        let alignment_offset = align_stack(text_buffer, rsp_offset - arguments_size);
        
        let arguments_size_aligned = (arguments_size + 15) & (!15);
        reserve_stack_space(text_buffer, arguments_size_aligned);

        let offset = 0;

        for (let i = 0; i < function_call_node->arguments.len(); i = i + 1) {
            let argument = function_call_node->arguments[i];
            let argument_type = compile_expression_into_register(text_buffer, argument, stack_frame, RAX, RVALUE);

            let size = get_size(argument_type);
            let word_size = get_word_size(size);

            if (size != get_size(function_signature->parameters[i]->type)) {
                print_location_of_error(function_call_node->arguments[i]->loc);
                error("Mismatch in argument size for the argument with index " + int_to_str(i) + " of function " + name + ". Expected " + debug_variable_type_name(function_signature->parameters[i]->type) + ", got " + debug_variable_type_name(argument_type) + "\n");
            }

            offset = offset + size;
            push_register(text_buffer, make_reg(RAX), argument_type, arguments_size - offset, arguments_size_aligned);
        }

        let return_type = function_signature->return_type;
        //add_to_text_buffer(text_buffer, "\tcall " + name + "\n");
        add_instruction(text_buffer, make_label(name), 0 as Operand*, CALL, VOID);

        if (return_type != VOID) {
            //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(return_type)) + " " + get_register_for_type('a', return_type) + ", " + get_register_for_type(reg, return_type) + "\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(reg), MOV, return_type);
        }

        if (current_target == X86_64) {
            for (let i = 0; i < function_signature->parameters.len(); i = i + 1) {
                let argument_size = get_size(function_signature->parameters[i]->type);
                //add_to_text_buffer(text_buffer, "\taddq $" + int_to_str(argument_size) + ", %rsp\n");
                add_instruction(text_buffer, make_imm(argument_size as long), make_reg(RSP), ADD, LONG_VARIABLE);
                rsp_offset = rsp_offset + argument_size;
            }
        }
        free_stack_space(text_buffer, arguments_size_aligned);

        dealign_stack(text_buffer, alignment_offset);
        return return_type;
    }
}


fn compile_expression_into_register(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, reg: long, type: int): int {
    if (node->type == EXPRESSION_INT) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("Int expression is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str((node->node as IntNode*)->value) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_imm((node->node as IntNode*)->value as long), make_reg(reg), MOV, INT_VARIABLE);
        return INT_VARIABLE;
    }
    elseif (node->type == EXPRESSION_LONG) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("Long expression is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tmovq $" + long_to_str((node->node as LongNode*)->value) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_imm((node->node as LongNode*)->value as long), make_reg(reg), MOV, LONG_VARIABLE);
        return LONG_VARIABLE;
    }
    elseif (node->type == EXPRESSION_TRUE) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("True expression is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tmovb $1, " + get_register_for_type(reg, BOOL_VARIABLE) + "\n");
        add_instruction(text_buffer, make_imm(1 as long), make_reg(reg), MOV, BOOL_VARIABLE);

        return BOOL_VARIABLE;
    }
    elseif (node->type == EXPRESSION_FALSE) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("False expression is not allowed as lvalue\n");
        }
        //add_to_text_buffer(text_buffer, "\tmovb $0, " + get_register_for_type(reg, BOOL_VARIABLE) + "\n");
        add_instruction(text_buffer, make_imm(0 as long), make_reg(reg), MOV, BOOL_VARIABLE);

        return BOOL_VARIABLE;
    }
    elseif (node->type == EXPRESSION_VARIABLE) {
        let name = (node->node as VariableNode*)->name;
        let variable = get_variable(stack_frame, name);
        if (variable) {
            let variable_type = variable->type;
            if (type == LVALUE) { 
                variable_type = to_pointer(variable_type);
            }
            if (type == RVALUE) {
                //add_to_text_buffer(text_buffer, "\tmov" + word_size + " " + variable->offset.int_to_str() + "(%rbp), " + register_name + "\n");
                add_instruction(text_buffer, make_mem(make_reg(RBP), 0 as Operand*, 0, variable->offset, REGISTER_RELATIVE), make_reg(reg), LOAD, variable_type);
            }
            elseif (type == LVALUE) {
                //add_to_text_buffer(text_buffer, "\tleaq" + " " + variable->offset.int_to_str() + "(%rbp), " + register_name + "\n");
                add_instruction(text_buffer, make_mem(make_reg(RBP), 0 as Operand*, 0, variable->offset, REGISTER_RELATIVE), make_reg(reg), LEA, LONG_VARIABLE);
            }
            return variable_type;
        }
        else {
            let global_variable = get_global_variable(global_scope, name);
            let variable_type = UNDEFINED_VARIABLE;
            if (global_variable) {
                variable_type = global_variable->type;
                if (type == LVALUE) {
                    variable_type = to_pointer(variable_type);
                }
                if (type == RVALUE) {
                    if (is_const(variable_type)) {
                        variable_type = variable_type ^ (1 << 24);
                        if (variable_type == INT_VARIABLE) {
                            //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str(*(global_variable->value as int*)) + ", " + register_name + "\n");
                        }
                        elseif (variable_type == LONG_VARIABLE) {
                            //add_to_text_buffer(text_buffer, "\tmovq $" + long_to_str(*(global_variable->value as long*)) + ", " + register_name + "\n");
                        }
                        else {
                            print_location_of_error(node->loc);
                            error("Unknown const variable type " + debug_variable_type_name(variable_type) + "\n");
                        }
                        add_instruction(text_buffer, make_imm(*(global_variable->value as int*) as long), make_reg(reg), MOV, variable_type);
                    }
                    else {
                        //add_to_text_buffer(text_buffer, "\tmov" + word_size + " ." + global_variable->name + "(%rip), " + register_name + "\n");
                        add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(reg), LOADGLOBL, variable_type);
                    }
                }
                elseif (type == LVALUE) {
                    if (is_const(variable_type)) {
                        error("Const variables cannot be lvalues\n");
                    }
                    //add_to_text_buffer(text_buffer, "\tleaq" + " ." + global_variable->name + "(%rip), " + register_name + "\n");
                    add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(reg), LEAGLOBL, LONG_VARIABLE);
                }
            }
            else {
                print_location_of_error(node->loc);
                error("Global variable " + name + " not found\n");
            }
            return variable_type;
        }
    }
    elseif (node->type == EXPRESSION_BINARY) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("Binary expression is not allowed as lvalue\n");
        }
        let expression_type = compile_binary_expression(text_buffer, node, stack_frame);
        //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(expression_type)) + " " + get_register_for_type('a', expression_type) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_reg(RAX), make_reg(reg), MOV, expression_type);

        return expression_type;
    }
    elseif (node->type == EXPRESSION_UNARY) {
        let expression_type = compile_unary_expression(text_buffer, node, stack_frame, type);
        //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(expression_type)) + " " + get_register_for_type('a', expression_type) + ", " + register_name + "\n");
        add_instruction(text_buffer, make_reg(RAX), make_reg(reg), MOV, expression_type);
        return expression_type;
    }
    elseif (node->type == EXPRESSION_STRING_LITERAL) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("String literal is not allowed as lvalue\n");
        }
        let string_node = (node->node as StringLiteralNode*)->name;
        let global_variable = get_global_variable(global_scope, string_node);
        //add_to_text_buffer(text_buffer, "\tleaq ." + global_variable->name + "(%rip), " + register_name + "\n");
        add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(reg), LEAGLOBL, LONG_VARIABLE);
        return global_variable->type;
    }
    elseif (node->type == EXPRESSION_CHAR) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("Char is not allowed as lvalue\n");
        }
        let char_node = (node->node as CharNode*)->name;
        let global_variable = get_global_variable(global_scope, char_node);
        //add_to_text_buffer(text_buffer, "\tmovb ." + global_variable->name + "(%rip), " + register_name + "\n");
        add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(reg), LOADGLOBL, CHAR_VARIABLE);
        return global_variable->type;
    }
    elseif (node->type == EXPRESSION_FUNCTION_CALL) {
        let return_type = compile_function_call(node, text_buffer, stack_frame, reg, type);
        if (return_type == VOID) {
            print_location_of_error(node->loc);
            error("Can't assign to void\n");
        }
        return return_type;
    }
    elseif (node->type == EXPRESSION_NEW) {
        if (type == LVALUE) {
            print_location_of_error(node->loc);
            error("New is not allowed as lvalue\n");
        }
        let new_node = (node->node as NewNode*);
        let node_type = new_node->type;
        let alignment_offset = align_stack(text_buffer, rsp_offset);

        if (is_pointer(node_type)) {
            // TODO: put malloc in other c functions in special emit stdlib functions
            let element_type = dereference_type(node_type);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type)) + ", %rdi\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) as long), make_reg(RDI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_stdlib_label("malloc"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(RDI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $0, %rsi\n");
            add_instruction(text_buffer, make_imm(0 as long), make_reg(RSI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type)) + ", %rdx\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) as long), make_reg(RDX), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall memset\n");
            add_instruction(text_buffer, make_stdlib_label("memset"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, " + get_register_for_type(reg, node_type) + "\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(reg), MOV, node_type);
        }
        elseif (is_array(node_type)) {
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(16) + ", %rdi\n");
            add_instruction(text_buffer, make_imm(16 as long), make_reg(RDI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_stdlib_label("malloc"), 0 as Operand*, CALL, VOID);

            let element_type = dereference_type(dereference_type(node_type));
            let base_capacity = 4;
            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rbx\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(RBX), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovl $0, " + int_to_str(8) + "(%rbx)\n");
            add_instruction(text_buffer, make_imm(0 as long), make_mem(make_reg(RBX), 0 as Operand*, 0, 8, REGISTER_RELATIVE), STORE, INT_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str(base_capacity) + ", " + int_to_str(12) + "(%rbx)\n");
            add_instruction(text_buffer, make_imm(base_capacity as long), make_mem(make_reg(RBX), 0 as Operand*, 0, 12, REGISTER_RELATIVE), STORE, INT_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type) * base_capacity) + ", %rdi\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) * base_capacity as long), make_reg(RDI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_stdlib_label("malloc"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(RDI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $0, %rsi\n");
            add_instruction(text_buffer, make_imm(0 as long), make_reg(RSI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq $" + int_to_str(get_size(element_type) * base_capacity) + ", %rdx\n");
            add_instruction(text_buffer, make_imm(get_size(element_type) * base_capacity as long), make_reg(RDX), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall memset\n");
            add_instruction(text_buffer, make_stdlib_label("memset"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %rax, " + int_to_str(0) + "(%rbx)\n");
            add_instruction(text_buffer, make_reg(RAX), make_mem(make_reg(RBX), 0 as Operand*, 0, 0, REGISTER_RELATIVE), STORE, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq %rbx, " + get_register_for_type(reg, node_type) + "\n");
            add_instruction(text_buffer, make_reg(RBX), make_reg(reg), MOV, LONG_VARIABLE);
        }
        else {
            print_location_of_error(node->loc);
            error("New keyword can only be used to create pointers and arrays\n");
        }
        dealign_stack(text_buffer, alignment_offset);
        return node_type;
    }
    elseif (node->type == EXPRESSION_ARROW || node->type == EXPRESSION_DOUBLE_COLON) {
        let access_node = (node->node as AccessNode*);
        let lrtype = RVALUE;
        if (node->type == EXPRESSION_DOUBLE_COLON) {
            lrtype = LVALUE;
        }
        let left_type = compile_expression_into_register(text_buffer, access_node->left, stack_frame, RAX, lrtype);
        if (!is_pointer(left_type)) {
            print_location_of_error(node->loc);
            error("Expected pointer type, got " + debug_variable_type_name(left_type) + "\n");
        }

        left_type = dereference_type(left_type);
        if (!(!is_pointer(left_type) && !is_array(left_type) && is_struct(left_type))) {
            print_location_of_error(node->loc);
            error("Expected struct type, got " + debug_variable_type_name(left_type) + "\n");
        }
        let struct_definition = get_struct_with_index(struct_registry, left_type ^ (1 << 7));
        let member = get_struct_member(struct_definition, (access_node->member->node as StructMemberNode*)->name);
        let member_type = member->type;
        if (type == LVALUE) {
            member_type = to_pointer(member_type);
        }
        let member_offset = member->offset;
        if (type == RVALUE) {
            let word_size = get_word_size(get_size(member_type));
            //add_to_text_buffer(text_buffer, "\tmov" + word_size + " " + int_to_str(member_offset) + "(" + pointer_register_name + "), " + register_name + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, member_offset, REGISTER_RELATIVE), make_reg(reg), LOAD, member_type);
        }
        elseif (type == LVALUE) {
            //add_to_text_buffer(text_buffer, "\tleaq" + " " + int_to_str(member_offset) + "(" + pointer_register_name + "), " + register_name + "\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, member_offset, REGISTER_RELATIVE), make_reg(reg), LEA, LONG_VARIABLE);
        }
        return member_type;
    }
    elseif (node->type == EXPRESSION_INDEX) {
        let index_node = (node->node as IndexNode*);
        let left_type = compile_expression_into_register(text_buffer, index_node->left, stack_frame, RAX, RVALUE);
        if (left_type != STRING_VARIABLE && !is_array(left_type) && !is_pointer(left_type)) {
            print_location_of_error(node->loc);
            error("Expected string, array or pointer type, got " + debug_variable_type_name(left_type) + "\n");
        }
        if (is_array(left_type)) {
            //add_to_text_buffer(text_buffer, "\tmovq (%rax), %rax\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(RAX), LOAD, LONG_VARIABLE);
        }

        let element_type: int;
        if (is_array(left_type))  {
            element_type = dereference_type(dereference_type(left_type));
        }
        elseif (is_pointer(left_type)) {
            element_type = dereference_type(left_type);
        }
        else {
            element_type = CHAR_VARIABLE;
        }

        if (index_node->index->type != EXPRESSION_RANGE) {
            reserve_stack_space(text_buffer, 16);
            push_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);

            let index_type = compile_expression_into_register(text_buffer, index_node->index, stack_frame, RDX, RVALUE);

            if (index_type != INT_VARIABLE && index_type != LONG_VARIABLE) {
                print_location_of_error(node->loc);
                error("Expected int type, got " + debug_variable_type_name(index_type) + "\n");
            }
            pop_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);
            free_stack_space(text_buffer, 16);

            //add_to_text_buffer(text_buffer, "\tleaq (%rax, %rdx, " + int_to_str(get_size(element_type)) + "), %rax\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), make_reg(RDX), get_size(element_type), 0, REGISTER_INDEXED), make_reg(RAX), LEA, LONG_VARIABLE);
            if (type == LVALUE) {
                element_type = to_pointer(element_type);
            }
            if (type == RVALUE) {
                //add_to_text_buffer(text_buffer, "\tmov" + word_size + " (%rax), " + register_name + "\n");
                add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(reg), LOAD, element_type);
            } elseif (type == LVALUE) {
                //add_to_text_buffer(text_buffer, "\tmovq %rax, " + register_name + "\n");
                add_instruction(text_buffer, make_reg(RAX), make_reg(reg), MOV, element_type);
            }
            return element_type;
        }
        else {
            if (is_array(left_type) || is_pointer(left_type)) {
                print_location_of_error(node->loc);
                error("EXPRESSION RANGE NOT CURRENTLY SUPPORTED FOR ARRAYS AND POINTERS\n");
            }

            let range_node = (index_node->index->node as RangeNode*);

            reserve_stack_space(text_buffer, 16);
            push_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);
            let left_index_type = compile_expression_into_register(text_buffer, range_node->left, stack_frame, RAX, RVALUE);

            if (left_index_type != INT_VARIABLE && left_index_type != LONG_VARIABLE) {
                print_location_of_error(node->loc);
                error("Expected int type, got " + debug_variable_type_name(left_index_type) + "\n");
            }
            if (left_index_type == INT_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovslq %eax, %r12\n");
                add_instruction(text_buffer, make_reg(RAX), make_reg(R12), encode_sizes_in_opcode(MOVS, INT_VARIABLE, LONG_VARIABLE), VOID);
            }
            elseif (left_index_type == LONG_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovq %rax, %r12\n");
                add_instruction(text_buffer, make_reg(RAX), make_reg(R12), MOV, LONG_VARIABLE);
            }

            let right_index_type = compile_expression_into_register(text_buffer, range_node->right, stack_frame, RAX, RVALUE);
            if (right_index_type != INT_VARIABLE && right_index_type != LONG_VARIABLE) {
                print_location_of_error(node->loc);
                error("Expected int type, got " + debug_variable_type_name(right_index_type) + "\n");
            }

            if (right_index_type == INT_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovslq %eax, %r13\n");
                add_instruction(text_buffer, make_reg(RAX), make_reg(R13), encode_sizes_in_opcode(MOVS, INT_VARIABLE, LONG_VARIABLE), VOID);
            }
            elseif (right_index_type == LONG_VARIABLE) {
                //add_to_text_buffer(text_buffer, "\tmovq %rax, %r13\n");
                add_instruction(text_buffer, make_reg(RAX), make_reg(R13), MOV, LONG_VARIABLE);
            }

            pop_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);
            free_stack_space(text_buffer, 16);

            //add_to_text_buffer(text_buffer, "\tsubq %r12, %r13\n");
            add_instruction(text_buffer, make_reg(R12), make_reg(R13), SUB, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tleaq (%rax, %r12, " + int_to_str(get_size(element_type)) + "), %r14\n");
            add_instruction(text_buffer, make_mem(make_reg(RAX), make_reg(R12), get_size(element_type), 0, REGISTER_INDEXED), make_reg(R14), LEA, LONG_VARIABLE);

  
            let alignment_offset = align_stack(text_buffer, rsp_offset);
            //add_to_text_buffer(text_buffer, "\tleaq 1(,%r13, " + int_to_str(get_size(element_type)) + "), %rdi\n");
            add_instruction(text_buffer, make_mem(0 as Operand*, make_reg(R13), get_size(element_type), 1, REGISTER_INDEXED), make_reg(RDI), LEA, LONG_VARIABLE);
            add_instruction(text_buffer, make_imm(1 as long), make_reg(RDI), ADD, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall malloc\n");
            add_instruction(text_buffer, make_stdlib_label("malloc"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq %r13, %rdx\n");
            add_instruction(text_buffer, make_reg(R13), make_reg(RDX), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq %r14, %rsi\n");
            add_instruction(text_buffer, make_reg(R14), make_reg(RSI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tmovq %rax, %rdi\n");
            add_instruction(text_buffer, make_reg(RAX), make_reg(RDI), MOV, LONG_VARIABLE);
            //add_to_text_buffer(text_buffer, "\tcall memcpy\n");
            add_instruction(text_buffer, make_stdlib_label("memcpy"), 0 as Operand*, CALL, VOID);

            //add_to_text_buffer(text_buffer, "\tmovq $0, (%rax, %r13, " + int_to_str(get_size(element_type)) + ")\n");
            add_instruction(text_buffer, make_imm(0 as long), make_mem(make_reg(RAX), make_reg(R13), get_size(element_type), 0, REGISTER_INDEXED), STORE, LONG_VARIABLE);
            dealign_stack(text_buffer, alignment_offset);
            return STRING_VARIABLE;
        }
    }
    elseif (node->type == EXPRESSION_AS) {
        let as_node = (node->node as AsNode*);
        let value_type = compile_expression_into_register(text_buffer, as_node->value, stack_frame, reg, RVALUE);
        let cast_type = as_node->type;

        let value_size = get_size(value_type);
        let cast_size = get_size(cast_type);
        if (value_size == cast_size) {
            return cast_type;
        }

        if (cast_size > value_size) {
            //add_to_text_buffer(text_buffer, "\tmovs" + get_word_size(value_size) + get_word_size(cast_size) + " " + get_register_for_type(reg, value_type) + ", " + get_register_for_type(reg, cast_type) + "\n");
            add_instruction(text_buffer, make_reg(reg), make_reg(reg), encode_sizes_in_opcode(MOVS, value_type, cast_type), VOID);
        }
        else {
            warn("Narrowing conversion from " + debug_variable_type_name(value_type) + " to " + debug_variable_type_name(cast_type) + "\n");
        }
        return cast_type;
    }
    print_location_of_error(node->loc);
    error("Unknown expression type to put in register " + int_to_str(node->type) + "\n");
    return VOID;
}

fn compile_assign(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, type: int) {
    let assign_node = (node->node as AssignNode*);
    let name = assign_node->name;

    let variable_type = 0;
    if (text_buffer) {
        if (type == STATEMENT_ASSIGN) {
            variable_type = compile_expression_into_register(text_buffer, assign_node->lvalue, stack_frame, RAX, LVALUE);

            reserve_stack_space(text_buffer, 16);
            push_register(text_buffer, make_reg(RAX), LONG_VARIABLE, 0, 16);
        }
    }

    if (assign_node->rvalue) {
        let expression_type: int;

        let rvalue_type = assign_node->rvalue->type;
        if (rvalue_type == EXPRESSION_INT) {
            expression_type = INT_VARIABLE;

            let int_node = (assign_node->rvalue->node as IntNode*);
            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tmovl $" + int_to_str(int_node->value) + ", %eax\n");
                add_instruction(text_buffer, make_imm(int_node->value as long), make_reg(RAX), MOV, INT_VARIABLE);
            }
            else {
                if (assign_node->is_const) {
                    expression_type = to_const(expression_type);
                }
                let intPtr = new int*;
                *intPtr = int_node->value;
                add_global_variable(global_scope, name, intPtr as ptr, expression_type);
            }
        }
        elseif (rvalue_type == EXPRESSION_LONG) {
            expression_type = LONG_VARIABLE;
            let long_node = (assign_node->rvalue->node as LongNode*);
            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tmovq $" + long_to_str(long_node->value) + ", %rax\n");
                add_instruction(text_buffer, make_imm(long_node->value as long), make_reg(RAX), MOV, LONG_VARIABLE);
            }
            else {
                if (assign_node->is_const) {
                    expression_type = to_const(expression_type);
                }
                let longPtr = new long*;
                *longPtr = long_node->value; 
                add_global_variable(global_scope, name, longPtr as ptr, expression_type);
            }
        }
        elseif (rvalue_type == EXPRESSION_FUNCTION_CALL) {
            let return_type = compile_function_call(assign_node->rvalue, text_buffer, stack_frame, RAX, RVALUE);
            if (return_type == VOID) {
                print_location_of_error(node->loc);
                error("Can't assign to void\n");
            }
            expression_type = return_type;
        }
        elseif (rvalue_type == EXPRESSION_STRING_LITERAL) {
            expression_type = STRING_VARIABLE;

            let string_node = (assign_node->rvalue->node as StringLiteralNode*);
            let global_variable = get_global_variable(global_scope, string_node->name);

            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tleaq ." + global_variable->name + "(%rip), %rax\n");
                add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(RAX), LEAGLOBL, LONG_VARIABLE);
            }
            else {
                add_global_variable(global_scope, name, global_variable->name as ptr, expression_type);
            }
        }
        elseif (rvalue_type == EXPRESSION_CHAR) {
            let char_node = (assign_node->rvalue->node as CharNode*);
            let global_variable = get_global_variable(global_scope, char_node->name);
            expression_type = CHAR_VARIABLE;
            if (text_buffer) {
                //add_to_text_buffer(text_buffer, "\tmovb ." + global_variable->name + "(%rip), %al\n");
                add_instruction(text_buffer, make_relative_label(global_variable->name), make_reg(RAX), LOADGLOBL, CHAR_VARIABLE);
            }
            else {
                global_variable->name = name;
            }
        }
        elseif (rvalue_type == EXPRESSION_BINARY) {
            expression_type = compile_binary_expression(text_buffer, assign_node->rvalue, stack_frame);
        }
        elseif (rvalue_type == EXPRESSION_UNARY) {
            expression_type = compile_unary_expression(text_buffer, assign_node->rvalue, stack_frame, RVALUE);
        }
        elseif (rvalue_type == EXPRESSION_VARIABLE || rvalue_type == EXPRESSION_INDEX || rvalue_type == EXPRESSION_AS || rvalue_type == EXPRESSION_NEW || rvalue_type == EXPRESSION_ARROW || rvalue_type == EXPRESSION_TRUE || rvalue_type == EXPRESSION_FALSE || rvalue_type == EXPRESSION_DOUBLE_COLON) {
            expression_type = compile_expression_into_register(text_buffer, assign_node->rvalue, stack_frame, RAX, RVALUE);
        }
        else {
            print_location_of_error(node->loc);
            error("Unknown expression type to assign" + int_to_str(rvalue_type) + "\n");
        }



        if ((text_buffer != (0 as ptr)) && (type == STATEMENT_ASSIGN)) {
            variable_type = dereference_type(variable_type);
            if (get_underlying_type(variable_type) != get_underlying_type(expression_type)) {
                if (!(variable_type == PTR_VARIABLE && (is_pointer(expression_type) || is_array(expression_type)))) {
                    print_location_of_error(node->loc);
                    error("Implicit conversion not possible. Trying to assign type " + debug_variable_type_name(expression_type) + " to variable type " + debug_variable_type_name(variable_type) + "\n");
                }
            }

            pop_register(text_buffer, make_reg(RBX), LONG_VARIABLE, 0, 16);
            free_stack_space(text_buffer, 16);
            //add_to_text_buffer(text_buffer, "\tmov" + get_word_size(get_size(variable_type)) + " " + get_register_for_type('a', variable_type) + ", (%rbx)\n");
            add_instruction(text_buffer, make_reg(RAX), make_mem(make_reg(RBX), 0 as Operand*, 0, 0, REGISTER_RELATIVE), STORE, variable_type);
        }

        if (text_buffer != (0 as ptr) && type == STATEMENT_LET) {
            let variable_node = get_variable(stack_frame, name);
            if (variable_node) {
                print_location_of_error(node->loc);
                error("Variable named: " + name + " already declared\n");
            }
            variable_node = add_variable(stack_frame, name, expression_type, 0);

            let stack_variable = make_stack(variable_node->offset);
            add_instruction(text_buffer, make_reg(RAX), stack_variable, STORE, expression_type);
        }
    }
    else {
        if (assign_node->type == UNDEFINED_VARIABLE) {
            print_location_of_error(node->loc);
            error("Cannot create/assign to a variable because neither the value nor the type was provided\n");
        }

        let zero_buffer = new char[];
        for (let i = 0; i < get_size(assign_node->type); i = i + 1) {
            zero_buffer.append('\0');
        }
        add_global_variable(global_scope, name, (*zero_buffer) as ptr, assign_node->type);
    }
}


fn compile_if_jump(text_buffer: TextBuffer*, if_statement_node: IfStatementNode*, index: int, i: int) {
    if (if_statement_node->else_if_count > i + 1) {
        //add_to_text_buffer(text_buffer, "\tjz .L" + int_to_str(index) + "_elseif_" + int_to_str(i + 1) + "\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(index) + "_elseif_" + int_to_str(i + 1)), 0 as Operand*, JMPZ, VOID);
    }
    elseif (if_statement_node->else_block) {
        //add_to_text_buffer(text_buffer, "\tjz .L" + int_to_str(index) + "_else\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(index) + "_else"), 0 as Operand*, JMPZ, VOID);
    }
    else {
        //add_to_text_buffer(text_buffer, "\tjz .L" + int_to_str(index) + "_end\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(index) + "_end"), 0 as Operand*, JMPZ, VOID);
    }
}

fn compile_statement(text_buffer: TextBuffer*, stack_frame: StackFrame*, statement: AstNode*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) 

fn compile_block(text_buffer: TextBuffer*, stack_frame: StackFrame*, block: AstBlock*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {
    for (let i = 0; i < block->statements.len(); i = i + 1) {
        compile_statement(text_buffer, stack_frame, block->statements[i], curr_func, curr_loop);
    }
}

fn compile_if_block(text_buffer: TextBuffer*, if_block: AstBlock*, stack_frame: StackFrame*, index: int, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {
    let block_stack_frame = new_stack_frame(stack_frame);
    let block_text_buffer = new_text_buffer();


    compile_block(block_text_buffer, block_stack_frame, if_block, curr_func, curr_loop);

    //add_to_text_buffer(block_text_buffer, "\tjmp .L" + int_to_str(index) + "_end\n");
    add_instruction(block_text_buffer, make_label("L" + int_to_str(index) + "_end"), 0 as Operand*, JMP, VOID);

    allocate_stack_space(text_buffer, block_stack_frame);
    terminate_buffer(block_text_buffer);
    add_to_text_buffer(text_buffer, *(block_text_buffer->buffer));
    deallocate_stack_space(text_buffer, block_stack_frame);
    delete_text_buffer(block_text_buffer);
}

fn compile_if(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {

    let if_statement_node = (node->node as IfStatementNode*);

    let index = get_label_index();

    let conditional_node = if_statement_node->condition;

    let conditional_type = compile_expression_into_register(text_buffer, conditional_node, stack_frame, RAX, RVALUE);
    //add_to_text_buffer(text_buffer, "\tcmp $0, " + get_register_for_type('a', conditional_type) + "\n");
    add_instruction(text_buffer, make_imm(0 as long), make_reg(RAX), CMP, conditional_type);
    compile_if_jump(text_buffer, if_statement_node, index, -1);

    compile_if_block(text_buffer, if_statement_node->then_block, stack_frame, index, curr_func, curr_loop);

    for (let i = 0; i < if_statement_node->else_if_count; i = i + 1) {
        let elseif_conditional_node = if_statement_node->else_if_conditions[i];

        add_to_text_buffer(text_buffer, ".L" + int_to_str(index) + "_elseif_" + int_to_str(i) + ":\n");

        let elseif_conditional_type = compile_expression_into_register(text_buffer, elseif_conditional_node, stack_frame, RAX, RVALUE);
        //add_to_text_buffer(text_buffer, "\tcmp $0, " + get_register_for_type('a', elseif_conditional_type) + "\n");
        add_instruction(text_buffer, make_imm(0 as long), make_reg(RAX), CMP, elseif_conditional_type);
        compile_if_jump(text_buffer, if_statement_node, index, i);

        compile_if_block(text_buffer, if_statement_node->else_if_blocks[i], stack_frame, index, curr_func, curr_loop);
    }

    if (if_statement_node->else_block) {
        add_to_text_buffer(text_buffer, ".L" + int_to_str(index) + "_else:\n");

        compile_if_block(text_buffer, if_statement_node->else_block, stack_frame, index, curr_func, curr_loop);
    }

    add_to_text_buffer(text_buffer, ".L" + int_to_str(index) + "_end:\n");
}

fn compile_return(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*): int {
    let return_node = (node->node as ReturnNode*);

    if (curr_func == (0 as FunctionSignature*)) {
        print_location_of_error(node->loc);
        error("Return called from outside of a function\n");
    }

    if (return_node->value == (0 as AstNode*)) {
        //add_to_text_buffer(text_buffer, "\tleave\n");
        add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, LEAVE, VOID);
        //add_to_text_buffer(text_buffer, "\tret\n");
        add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, RET, VOID);
        return VOID;
    }

    let return_type = curr_func->return_type;
    let return_expression_type = compile_expression_into_register(text_buffer, return_node->value, stack_frame, RAX, RVALUE);

    if (get_underlying_type(return_type) != get_underlying_type(return_expression_type)) {
        print_location_of_error(node->loc);
        error("Type in return statement doesnt match the return type of function " + curr_func->name + ". Expected " + debug_variable_type_name(return_type) + ", got " + debug_variable_type_name(return_expression_type) + "\n");
        error("Underlying types are: " + debug_variable_type_name(get_underlying_type(return_type)) + " and " + debug_variable_type_name(get_underlying_type(return_expression_type)) + "\n");
    }

    deallocate_stack_space(text_buffer, stack_frame);
    //add_to_text_buffer(text_buffer, "\tleave\n");
    add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, LEAVE, VOID);
    //add_to_text_buffer(text_buffer, "\tret\n");
    add_instruction(text_buffer, 0 as Operand*, 0 as Operand*, RET, VOID);
    return return_type;
}

fn compile_delete(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*) {
    let delete_node = (node->node as DeleteNode*);
    let value_type = compile_expression_into_register(text_buffer, delete_node->value, stack_frame, RAX, RVALUE);

    if (delete_node->is_array) {
        if (!is_array(value_type)) {
            print_location_of_error(node->loc);
            error("Expected array type, got " + debug_variable_type_name(value_type) + "\n");
        }
        add_instruction(text_buffer, make_reg(RAX), make_reg(RBX), MOV, LONG_VARIABLE);
        add_instruction(text_buffer, make_mem(make_reg(RAX), 0 as Operand*, 0, 0, REGISTER_RELATIVE), make_reg(RDI), LOAD, LONG_VARIABLE);
        add_instruction(text_buffer, make_stdlib_label("free"), 0 as Operand*, CALL, VOID);

        add_instruction(text_buffer, make_reg(RBX), make_reg(RDI), MOV, LONG_VARIABLE);
        add_instruction(text_buffer, make_stdlib_label("free"), 0 as Operand*, CALL, VOID);
    }
    else {
        if (!is_pointer(value_type)) {
            print_location_of_error(node->loc);
            error("Expected pointer type, got " + debug_variable_type_name(value_type) + "\n");
        }

        add_instruction(text_buffer, make_reg(RAX), make_reg(RDI), MOV, LONG_VARIABLE);
        add_instruction(text_buffer, make_stdlib_label("free"), 0 as Operand*, CALL, VOID);
    }
}

fn compile_function(node: AstNode*, stack_frame: StackFrame*) {
    let function_node = (node->node as FunctionNode*);
    if ((function_node->body) == (0 as ptr)) {
        return;
    }

    let function_stack_frame = new_stack_frame(0 as StackFrame*);
    let function_text_buffer = new_text_buffer();
    let function_signature = function_node->function_signature;

    let name = function_node->name;
    if (name == "main") {
        if (current_target == AARCH64) {
            name = "_main";
        }
        add_variable(function_stack_frame, "argc", INT_VARIABLE, 0);
        add_variable(function_stack_frame, "argv", to_pointer(to_pointer(CHAR_VARIABLE)), 0);
    }
    for (let i = 0; i < function_signature->parameters.len(); i = i + 1) {
        let parameter = function_signature->parameters[i];
        add_variable(function_stack_frame, parameter->name, parameter->type, parameter->offset);
    }
    for (let i = 0; i < function_node->body->statements.len(); i = i + 1) {
        if (function_node->body->statements[i]->type == STATEMENT_RETURN) {
            let return_type = compile_return(function_text_buffer, function_node->body->statements[i], function_stack_frame, function_signature);
            if (get_underlying_type(return_type) != get_underlying_type(function_signature->return_type)) {
                print_location_of_error(node->loc);
                error("Return type mismatch in function " + function_node->name + ". Expected " + debug_variable_type_name(function_signature->return_type) + ", got " + debug_variable_type_name(return_type) + "\n");
                error("Underlying types are: " + debug_variable_type_name(get_underlying_type(function_signature->return_type)) + " and " + debug_variable_type_name(get_underlying_type(return_type)) + "\n");
            }
        }
        else {
            compile_statement(function_text_buffer, function_stack_frame, function_node->body->statements[i], function_signature, 0 as LoopSignature*);
        }
    }

    print(".globl " + name + "\n");
    print(name + ":\n");
    if (current_target == X86_64) {
        print(".cfi_startproc\n");
        print("\tpushq %rbp\n");
        print(".cfi_def_cfa_offset 16\n");
        print(".cfi_offset 6, -16\n");
        print("\tmovq %rsp, %rbp\n");
        print(".cfi_def_cfa_register 6\n");
    }
    elseif (current_target == AARCH64) {
        print("\tstp x29, x30, [sp, #-16]!\n");
        print("\tmov x29, sp\n");
    }
    rsp_offset = 0;



    allocate_stack_space(0 as TextBuffer*, function_stack_frame);
    if (name == "main") {
        rsp_offset = -16;
        print("\tmovl %edi, -4(%rbp)\n");
        print("\tmovq %rsi, -12(%rbp)\n");
    }
    if (name == "_main") {
        rsp_offset = -16;
        print("\tstr w0, [x29, #-4]\n");
        print("\tstr x1, [x29, #-12]\n");
    }
    terminate_buffer(function_text_buffer);
    print(*(function_text_buffer->buffer));
    deallocate_stack_space(0 as TextBuffer*, function_stack_frame);

    if (current_target == X86_64) {
        print("\tleave\n");
        print(".cfi_def_cfa 7, 8\n");
        print("\tret\n");
        print(".cfi_endproc\n");
    }
    elseif (current_target == AARCH64) {
        print("\tmov sp, x29\n");
        print("\tldp x29, x30, [sp], #16\n");
        print("\tret\n");
    } 
    delete_text_buffer(function_text_buffer);
}

fn compile_break(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_loop: LoopSignature*) {
    if (curr_loop == (0 as LoopSignature*)) {
        print_location_of_error(node->loc);
        error("Break called from outside of a loop\n");
    }

    if (curr_loop->type == STATEMENT_FOR) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_for_end\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_for_end"), 0 as Operand*, JMP, VOID);
    }
    elseif (curr_loop->type == STATEMENT_WHILE) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_while_end\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_while_end"), 0 as Operand*, JMP, VOID);
    }
    else {
        error("Unknown loop type " + int_to_str(curr_loop->type) + "\n");
    }
}

fn compile_continue(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_loop: LoopSignature*) {
    if (curr_loop == (0 as LoopSignature*)) {
        print_location_of_error(node->loc);
        error("Continue called from outside of a loop\n");
    }
    
    if (curr_loop->type == STATEMENT_FOR) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_for_inc\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_for_inc"), 0 as Operand*, JMP, VOID);
    }
    elseif (curr_loop->type == STATEMENT_WHILE) {
        //add_to_text_buffer(text_buffer, "\tjmp .L" + int_to_str(curr_loop->index) + "_while_start\n");
        add_instruction(text_buffer, make_label("L" + int_to_str(curr_loop->index) + "_for_inc"), 0 as Operand*, JMP, VOID);
    }
    else {
        error("Unknown loop type " + int_to_str(curr_loop->type) + "\n");
    }
}

fn compile_while(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*) {
    let while_statement_node = (node->node as WhileStatementNode*);

    let while_stack_frame = new_stack_frame(stack_frame);
    let while_text_buffer = new_text_buffer();

    let loop_signature = new LoopSignature*;

    let index = get_label_index();
    loop_signature->type = node->type;
    loop_signature->index = index;

    add_to_text_buffer(while_text_buffer, ".L" + int_to_str(index) + "_while_start:\n");

    let condition_type = compile_expression_into_register(while_text_buffer, while_statement_node->condition, while_stack_frame, RAX, RVALUE);

    //add_to_text_buffer(while_text_buffer, "\tcmp $0, " + get_register_for_type('a', condition_type) + "\n");
    add_instruction(while_text_buffer, make_imm(0 as long), make_reg(RAX), CMP, condition_type);
    //add_to_text_buffer(while_text_buffer, "\tjz .L" + int_to_str(index) + "_while_end\n");
    add_instruction(while_text_buffer, make_label("L" + int_to_str(index) + "_while_end"), 0 as Operand*, JMPZ, VOID);

    compile_block(while_text_buffer, while_stack_frame, while_statement_node->body, curr_func, loop_signature);

    //add_to_text_buffer(while_text_buffer, "\tjmp .L" + int_to_str(index) + "_while_start\n");
    add_instruction(while_text_buffer, make_label("L" + int_to_str(index) + "_while_start"), 0 as Operand*, JMP, VOID);

    add_to_text_buffer(while_text_buffer, ".L" + int_to_str(index) + "_while_end:\n");

    allocate_stack_space(text_buffer, while_stack_frame);
    terminate_buffer(while_text_buffer);
    add_to_text_buffer(text_buffer, *(while_text_buffer->buffer));
    deallocate_stack_space(text_buffer, while_stack_frame);
    delete_text_buffer(while_text_buffer);
}
    
fn compile_for(text_buffer: TextBuffer*, node: AstNode*, stack_frame: StackFrame*, curr_func: FunctionSignature*) {
    let for_statement_node = (node->node as ForStatementNode*);
    
    let for_stack_frame = new_stack_frame(stack_frame);
    let for_text_buffer = new_text_buffer();

    let init_node = for_statement_node->initializer;
    let condition_node = for_statement_node->condition;
    let increment_node = for_statement_node->increment;
    let body_block = for_statement_node->body;

    compile_statement(for_text_buffer, for_stack_frame, init_node, curr_func, 0 as LoopSignature*);

    let index = get_label_index();
    let loop_signature = new LoopSignature*;
    loop_signature->type = node->type;
    loop_signature->index = index;

    add_to_text_buffer(for_text_buffer, ".L" + int_to_str(index) + "_for_start:\n");

    let condition_type = compile_expression_into_register(for_text_buffer, condition_node, for_stack_frame, RAX, RVALUE);
    //add_to_text_buffer(for_text_buffer, "\tcmp $0, " + get_register_for_type('a', condition_type) + "\n");
    add_instruction(for_text_buffer, make_imm(0 as long), make_reg(RAX), CMP, condition_type);
    //add_to_text_buffer(for_text_buffer, "\tjz .L" + int_to_str(index) + "_for_end\n");
    add_instruction(for_text_buffer, make_label("L" + int_to_str(index) + "_for_end"), 0 as Operand*, JMPZ, VOID);

    compile_block(for_text_buffer, for_stack_frame, body_block, curr_func, loop_signature);

    add_to_text_buffer(for_text_buffer, ".L" + int_to_str(index) + "_for_inc:\n");
    compile_statement(for_text_buffer, for_stack_frame, increment_node, curr_func, loop_signature);
    //add_to_text_buffer(for_text_buffer, "\tjmp .L" + int_to_str(index) + "_for_start\n");
    add_instruction(for_text_buffer, make_label("L" + int_to_str(index) + "_for_start"), 0 as Operand*, JMP, VOID);

    add_to_text_buffer(for_text_buffer, ".L" + int_to_str(index) + "_for_end:\n");

    allocate_stack_space(text_buffer, for_stack_frame);
    terminate_buffer(for_text_buffer);
    add_to_text_buffer(text_buffer, *(for_text_buffer->buffer));
    deallocate_stack_space(text_buffer, for_stack_frame);
    delete_text_buffer(for_text_buffer);
}

fn compile_file(file_name: str)

fn compile_statement(text_buffer: TextBuffer*, stack_frame: StackFrame*, statement: AstNode*, curr_func: FunctionSignature*, curr_loop: LoopSignature*) {
    print_loc(text_buffer, statement->loc);
    if (statement->type == STATEMENT_LET) {
        compile_assign(text_buffer, statement, stack_frame, statement->type);
    }
    elseif (statement->type == STATEMENT_ASSIGN) {
        compile_assign(text_buffer, statement, stack_frame, statement->type);
    }
    elseif (statement->type == STATEMENT_IF) {
        compile_if(text_buffer, statement, stack_frame, curr_func, curr_loop);
    }
    elseif (statement->type == STATEMENT_FUNCTION) {
        if (text_buffer != (0 as ptr)) {
            print_location_of_error(statement->loc);
            error("Nested functions are not supported\n");
        }
        compile_function(statement, stack_frame);
    }
    elseif (statement->type == STATEMENT_RETURN) {
        compile_return(text_buffer, statement, stack_frame, curr_func);
    }
    elseif (statement->type == STATEMENT_BREAK) {
        compile_break(text_buffer, statement, stack_frame, curr_loop);
    }
    elseif (statement->type == STATEMENT_CONTINUE) {
        compile_continue(text_buffer, statement, stack_frame, curr_loop);
    }
    elseif (statement->type == EXPRESSION_FUNCTION_CALL) {
        compile_function_call(statement, text_buffer, stack_frame, RAX, RVALUE);
    }
    elseif (statement->type == STATEMENT_WHILE) {
        compile_while(text_buffer, statement, stack_frame, curr_func);
    }
    elseif (statement->type == STATEMENT_FOR) {
        compile_for(text_buffer, statement, stack_frame, curr_func);
    }
    elseif (statement->type == STATEMENT_STRUCT || statement->type == STATEMENT_NONE) {

    }
    elseif (statement->type == STATEMENT_IMPORT) {
        let import_node = (statement->node as ImportNode*);
        compile_file(import_node->filename);
    }
    elseif (statement->type == STATEMENT_DELETE) {
        compile_delete(text_buffer, statement, stack_frame, curr_func);
    }
    else {
        print_location_of_error(statement->loc);
        error("Unknown statement type " + int_to_str(statement->type) + "\n");
    }
}
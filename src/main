import "enum"
import "lexer"
import "variable"
import "parser"
import "codegen"

import "builtin/x86"
import "builtin/aarch64"

fn get_index_of_last_slash(filepath: str): int {
    let index = filepath.len() - 1;
    while (index >= 0) {
        if (filepath[index] == '/') {
            return index;
        }
        index = index - 1;
    }
    return -1;
}

fn compile_file(file_name: str) {
    file_name = relative_directory + file_name;

    let old_token_index = token_index;
    token_index = 0;
    let old_lexer_position = lexer_position;
    lexer_position = 0;

    let old_input_text = input_text;
    input_text = read_file(file_name);
    text_size = len(input_text);

    let old_tokens = tokens;
    tokens = lex_all_tokens();
    token_count = tokens.len();

    let old_relative_directory = relative_directory;
    let index = get_index_of_last_slash(file_name);
    if (index != -1) {
        relative_directory = file_name[0..index + 1];
    }
    else {
        relative_directory = "";
    }
 
    while (peek_next_token() != (0 as Token*)) {
        if (peek_next_token()->type == END) {
            break;
        }
        let node = get_statement();

        compile_statement(0 as TextBuffer*, 0 as StackFrame*, node, 0 as FunctionSignature*, 0 as LoopSignature*);
    }
    input_text = old_input_text;
    text_size = len(input_text);

    tokens = old_tokens;
    if (tokens) {
        token_count = tokens.len();
    }
    token_index = old_token_index;
    lexer_position = old_lexer_position;
    relative_directory = old_relative_directory;
}


fn main(): int {

    if (argc != 3) {
        print("Usage: ./compiler [target] input_file\n");
        return 1;
    }

    if (argv[1] == "x86_64") {
        current_target = X86_64;
    }
    elseif (argv[1] == "aarch64") {
        current_target = AARCH64;
    }
    else {
        print("Unknown target " + argv[1] + "\n");
        return 1;
    }

    global_scope = new_global_scope();

    struct_registry = new StructRegistry*;
    struct_registry->definitions = new StructDefinition*[];
    function_registry = new FunctionRegistry*;
    function_registry->signatures = new FunctionSignature*[];

    instructions = new Instruction*[];
    register_names_byte = new str[];
    register_names_dword = new str[];
    register_names_qword = new str[];
    if (current_target == X86_64) {
        register_names_byte.append("%al");
        register_names_byte.append("%bl");
        register_names_byte.append("%cl");
        register_names_byte.append("%dl");
        register_names_byte.append("%sil");
        register_names_byte.append("%dil");
        register_names_byte.append("%bpl");
        register_names_byte.append("%spl");
        register_names_byte.append("%r8b");
        register_names_byte.append("%r9b");
        register_names_byte.append("%r10b");
        register_names_byte.append("%r11b");
        register_names_byte.append("%r12b");
        register_names_byte.append("%r13b");
        register_names_byte.append("%r14b");
        register_names_byte.append("%r15b");

        register_names_dword.append("%eax");
        register_names_dword.append("%ebx");
        register_names_dword.append("%ecx");
        register_names_dword.append("%edx");
        register_names_dword.append("%esi");
        register_names_dword.append("%edi");
        register_names_dword.append("%ebp");
        register_names_dword.append("%esp");
        register_names_dword.append("%r8d");
        register_names_dword.append("%r9d");
        register_names_dword.append("%r10d");
        register_names_dword.append("%r11d");
        register_names_dword.append("%r12d");
        register_names_dword.append("%r13d");
        register_names_dword.append("%r14d");
        register_names_dword.append("%r15d");

        register_names_qword.append("%rax"); // x0
        register_names_qword.append("%rbx"); // x19
        register_names_qword.append("%rcx"); // x3
        register_names_qword.append("%rdx"); // x2
        register_names_qword.append("%rsi"); // x1
        register_names_qword.append("%rdi"); // x0
        register_names_qword.append("%rbp"); // x29
        register_names_qword.append("%rsp"); // sp
        register_names_qword.append("%r8");  // x4
        register_names_qword.append("%r9");  // x5
        register_names_qword.append("%r10"); // x6
        register_names_qword.append("%r11"); // x7
        register_names_qword.append("%r12"); // x23
        register_names_qword.append("%r13"); // x20
        register_names_qword.append("%r14"); // x21
        register_names_qword.append("%r15"); // x22
    }
    elseif (current_target == AARCH64) {
        register_names_dword.append("w0");
        register_names_dword.append("w19");
        register_names_dword.append("w3");
        register_names_dword.append("w2");
        register_names_dword.append("w0");
        register_names_dword.append("w1");
        register_names_dword.append("w29");
        register_names_dword.append("wsp");
        register_names_dword.append("w4");
        register_names_dword.append("w5");
        register_names_dword.append("w6");
        register_names_dword.append("w7");
        register_names_dword.append("w23"); 
        register_names_dword.append("w20"); 
        register_names_dword.append("w21"); 
        register_names_dword.append("w22"); 

        register_names_qword.append("x0");  // rax 
        register_names_qword.append("x19"); // rbx
        register_names_qword.append("x3");  // rcx
        register_names_qword.append("x2");  // rdx
        register_names_qword.append("x1");  // rsi
        register_names_qword.append("x0");  // rdi
        register_names_qword.append("x29"); // rbp
        register_names_qword.append("sp");  // rsp
        register_names_qword.append("x4");  // r8
        register_names_qword.append("x5");  // r9
        register_names_qword.append("x6");  // r10
        register_names_qword.append("x7");  // r11
        register_names_qword.append("x23"); // r12
        register_names_qword.append("x20"); // r13
        register_names_qword.append("x21"); // r14
        register_names_qword.append("x22"); // r15
    }


    let print_signature = add_signature(function_registry);
    print_signature->name = "print";
    print_signature->return_type = VOID;
    add_parameter(print_signature, "str_var", STRING_VARIABLE);

    let warn_signature = add_signature(function_registry);
    warn_signature->name = "warn";
    warn_signature->return_type = VOID;
    add_parameter(warn_signature, "str_var", STRING_VARIABLE);

    let error_signature = add_signature(function_registry);
    error_signature->name = "error";
    error_signature->return_type = VOID;
    add_parameter(error_signature, "str_var", STRING_VARIABLE);

    let read_file_signature = add_signature(function_registry);
    read_file_signature->name = "read_file";
    read_file_signature->return_type = STRING_VARIABLE;
    add_parameter(read_file_signature, "str", STRING_VARIABLE);

    let int_to_str_signature = add_signature(function_registry);
    int_to_str_signature->name = "int_to_str";
    int_to_str_signature->return_type = STRING_VARIABLE;
    add_parameter(int_to_str_signature, "int_var", INT_VARIABLE);

    let long_to_str_signature = add_signature(function_registry);
    long_to_str_signature->name = "long_to_str";
    long_to_str_signature->return_type = STRING_VARIABLE;
    add_parameter(long_to_str_signature, "long_var", LONG_VARIABLE);

    let char_to_str_signature = add_signature(function_registry);
    char_to_str_signature->name = "char_to_str";
    char_to_str_signature->return_type = STRING_VARIABLE;
    add_parameter(char_to_str_signature, "char_var", CHAR_VARIABLE);


    if (current_target == X86_64) {
        print(".section .text\n");
        print(".extern memcpy\n");
        print(".extern memset\n");
        print(".extern malloc\n");
        print(".extern realloc\n");
        print(".extern strcmp\n");
        print(".extern strlen\n");
        print(".extern snprintf\n");
    } elseif (current_target == AARCH64) {
        print(".text\n");
    }

    compile_file(argv[2]); 

    if(current_target == X86_64) {
        print(print_asm_code_x86);
        print(warn_asm_code_x86);
        print(error_asm_code_x86);
        print(strlen_internal_asm_code_x86);

        print(long_to_str_asm_code_x86);
        print(int_to_str_asm_code_x86);
        print(char_to_str_asm_code_x86);

        print(read_file_asm_code_x86);

        print(append_char_asm_code_x86);
        print(append_long_asm_code_x86);
        print(append_quad_asm_code_x86);

        print(append_string_to_builder_asm_code_x86);
        print(append_char_to_builder_asm_code_x86);
    }
    elseif (current_target == AARCH64) {
        print(print_asm_code_aarch64);
        print(warn_asm_code_aarch64);
        print(error_asm_code_aarch64);
        print(strlen_internal_asm_code_aarch64);

        print(int_to_str_asm_code_aarch64);
        print(long_to_str_asm_code_aarch64);
        print(char_to_str_asm_code_aarch64);

        print(read_file_asm_code_aarch64);

        print(append_long_asm_code_aarch64);
        print(append_quad_asm_code_aarch64);
        print(append_char_asm_code_aarch64);

        print(append_string_to_builder_asm_code_aarch64);
        print(append_char_to_builder_asm_code_aarch64);
    }

    if (current_target == X86_64) {
        print(".section .data\n");
    } elseif (current_target == AARCH64) {
        print(".data\n");
        print(".align 8\n");
    }
    for (let i = 0; i < global_scope->variables.len(); i = i + 1) {
        let variable_type = global_scope->variables[i]->type;

        if (is_const(variable_type)) {
            continue;
        }


        if (variable_type == STRING_LITERAL_VARIABLE || variable_type == CHAR_VARIABLE) {
            continue;
        }
        if (current_target == X86_64) {
            print("\t." + global_scope->variables[i]->name + ":\t");
        } elseif (current_target == AARCH64) {
            print("\t_" + global_scope->variables[i]->name + ":\t");
        }
        if (is_pointer(variable_type) || is_array(variable_type)) {
            print(".quad " + *(global_scope->variables[i]->value as long*).long_to_str() + "\n");
        }
        elseif (variable_type == STRING_VARIABLE) {
            if (current_target == X86_64) {
                print(".quad ." + (global_scope->variables[i]->value as char*) + "\n");
            }
            elseif (current_target == AARCH64) {
                print(".quad _" + (global_scope->variables[i]->value as char*) + "\n");
            }
        }
        elseif (variable_type == INT_VARIABLE) {
            print(".quad " + (*(global_scope->variables[i]->value as int*)).int_to_str() + "\n");
        }
        elseif (variable_type == LONG_VARIABLE) {
            print(".quad " + *(global_scope->variables[i]->value as long*).long_to_str() + "\n");
        }

    }

    for (let i = 0; i < global_scope->variables.len(); i = i + 1) {
        let variable_type = global_scope->variables[i]->type;

        if (is_const(variable_type)) {
            continue;
        }

        if (variable_type != CHAR_VARIABLE) {
            continue;
        }
        if (current_target == X86_64) {
            print("\t." + global_scope->variables[i]->name + ":\t");
        } elseif (current_target == AARCH64) {
            print("\t_" + global_scope->variables[i]->name + ":\t");
        }
        
        if (variable_type == CHAR_VARIABLE) {
            print(".byte " + (*(global_scope->variables[i]->value as char*) as int).int_to_str() + "\n");
        }
    }
    
    if (current_target == X86_64) {
        print(".section .rodata\n");
    } elseif (current_target == AARCH64) {
        print(".const\n");
        print(".align 8\n");
    }
    for (let i = 0; i < global_scope->variables.len(); i = i + 1) {
        let variable_type = global_scope->variables[i]->type;
        if (is_const(variable_type)) {
            continue;
        }
        if (variable_type == STRING_LITERAL_VARIABLE) {
            if (current_target == X86_64) {
                print("\t." + global_scope->variables[i]->name + ":\t");
            }
            elseif (current_target == AARCH64) {
                print("\t_" + global_scope->variables[i]->name + ":\t");
            }
            print(".string \"" + ((global_scope->variables[i]->value) as char*) + "\"\n");
        }
    }
    if (current_target == X86_64) {
        print("\t.long_fmt:\t.string \"%ld\"\n");
        print("\t.int_fmt:\t.string \"%d\"\n");
        print(".section .bss\n");
        print("\tfile_statbuf:\t.skip 144\n");
    } elseif (current_target == AARCH64) {
        print("\t_long_fmt:\t.asciz \"%ld\"\n");
        print("\t_int_fmt:\t.asciz \"%d\"\n");
        print(".bss\n");
        print("\tfile_statbuf:\t.skip 144\n");
    }

    return 0;
}